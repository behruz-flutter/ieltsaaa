<!doctype html>
<html lang="uz">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>IELTS Speaking ‚Äî Auto-score (with PNG export)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
  <style>
    /* ----------------- Theme variables ----------------- */
    :root{
      /* Dark default */
      --bg: #071634;
      --bg2: #0b1930;
      --panel: #0e1330;
      --text: #ffffff;
      --muted: #b9c6e8;
      --brand: #7c9cff;
      --mint: #5eead4;
      --stroke: rgba(124,156,255,.16);
      --chip: #0c1230;
      --ring: #203060;
      --btn-bg: linear-gradient(180deg,#152443,#0f1a36);
      --btn-ghost-bg: rgba(255,255,255,0.03);
      --card-radius: 14px;
      --control-pad: 12px;
      --gutter: 24px;            /* spacing between containers */
      --section-gap: 20px;      /* gap above sections */
      --suspect-bg: rgba(255,79,79,0.12);
      --suspect-border: rgba(255,79,79,0.3);
      --ok-bg: rgba(92, 255, 199, 0.08);
      --ok-border: rgba(92, 255, 199, 0.18);
      /* error colors (theme-aware) */
      --err-bg: rgba(255,79,79,0.12);
      --err-border: rgba(255,79,79,0.3);
      --err-text: #ffb4b4;
      --ok-text: #bfffe6;
      --misplaced-bg: rgba(255,165,0,0.12);
      --misplaced-border: rgba(255,140,0,0.18);
      --misplaced-text: #ffb36b;
      --extra-bg: rgba(255,200,80,0.12);
      --extra-border: rgba(220,150,20,0.18);
      --extra-text: #ffe6b3;
    }
    [data-theme="light"]{
      --bg: #ffffff;
      --bg2: #f6f8ff;
      --panel: #ffffff;
      --text: #0b1020;
      --muted: #505a7a;
      --brand: #2b59ff;
      --mint: #0fcf97;
      --stroke: rgba(30,50,150,.08);
      --chip: #eef2ff;
      --ring: #dfe6ff;
      --btn-bg: linear-gradient(180deg,#f3f6ff,#eef3ff);
      --btn-ghost-bg: rgba(11,16,32,0.03);
      --suspect-bg: rgba(255,79,79,0.12);
      --suspect-border: rgba(255,79,79,0.2);
      --ok-bg: rgba(10,160,120,0.06);
      --ok-border: rgba(10,160,120,0.16);
      --err-bg: rgba(255,79,79,0.12);
      --err-border: rgba(255,79,79,0.22);
      --err-text: #7a0b0b;
      --ok-text: #0a6b46;
      --misplaced-bg: rgba(255,165,0,0.12);
      --misplaced-border: rgba(255,140,0,0.18);
      --misplaced-text: #8a4b00;
      --extra-bg: rgba(255,200,80,0.12);
      --extra-border: rgba(220,150,20,0.18);
      --extra-text: #6a4a00;
    }

    /* ----------------- Base resets ----------------- */
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);
      background:
        radial-gradient(1000px 600px at 120% -10%, rgba(24,34,74,.06) 0%, transparent 55%),
        radial-gradient(800px 500px at -20% 20%, rgba(21,32,74,.04) 0%, transparent 55%),
        linear-gradient(180deg, var(--bg) 0%, var(--bg2) 100%);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      transition: background-color .25s ease, color .18s ease;
      padding-bottom:32px;
    }

    .wrap{max-width:1200px;margin:0 auto;padding:28px}

    header{
      position:sticky; top:0; z-index:40;
      background: linear-gradient(180deg, rgba(11,16,32,.6), rgba(11,16,32,.45));
      backdrop-filter: saturate(115%) blur(6px);
      border-bottom:1px solid var(--stroke);
      padding:14px 0;
    }
    [data-theme="light"] header{
      background: linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.85));
    }

    .head{max-width:1200px;margin:0 auto;padding:8px 28px;display:flex;gap:16px;align-items:center}
    .logo{display:flex;gap:12px;align-items:center}
    .dot{width:12px;height:12px;border-radius:50%;background:linear-gradient(135deg,var(--brand),var(--mint));box-shadow:0 0 0 6px rgba(124,156,255,.06)}
    h1{font-size:clamp(18px,2.6vw,22px);margin:0}
    .sub{font-size:13px;color:var(--muted)}
    .spacer{flex:1}

    /* Buttons (compact) */
    .btn{
      appearance:none;
      -webkit-appearance:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      justify-content:center;
      background:var(--btn-bg);
      color:var(--text);
      border:1px solid var(--stroke);
      padding:8px 12px;
      border-radius:12px;
      font-weight:700;
      font-size:13px;
      line-height:1;
      cursor:pointer;
      min-height:38px;
      transition:transform .08s ease, opacity .08s ease, background .12s ease;
    }
    .btn:active{ transform:translateY(1px) }
    .btn.ghost{ background:var(--btn-ghost-bg); color:var(--text); }
    .btn.danger{ background:linear-gradient(180deg,#3a1420,#2a0e18); color:#fff }
    .btn.ok{ background:linear-gradient(180deg,#0b3b25,#07321b); color:#fff }

    .row{display:flex;gap:14px;flex-wrap:wrap;align-items:center}
    .label{font-size:13px;color:var(--muted)}
    .meter{height:10px;background:#06102a;border:1px solid var(--stroke);border-radius:999px;overflow:hidden}
    .timer{font-variant-numeric:tabular-nums;font-size:28px;font-weight:800}
    .pill{font-size:13px;padding:6px 10px;border-radius:999px;border:1px solid var(--stroke);background:var(--chip); color:var(--text)}
    .section{border:1px solid var(--stroke);background:var(--panel);border-radius:var(--card-radius);margin-top:var(--section-gap)}
    .section .head{padding:18px 16px}
    .section .body{padding:18px 16px;border-top:1px solid var(--stroke)}
    .card{background:linear-gradient(180deg,var(--bg2),var(--panel));border:1px solid var(--stroke);border-radius:var(--card-radius);padding:22px}
    .muted{color:var(--muted);font-size:14px;margin:0}

    .qa{display:grid;gap:10px}
    .question{padding:12px 14px;border:1px solid var(--stroke);background:var(--chip);border-radius:12px;position:relative;font-size:15px}
    textarea{width:100%;min-height:90px;border-radius:12px;border:1px solid var(--stroke);background:var(--chip);color:var(--text);padding:10px;font-size:14px}

    .audio-row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    audio{width:100%}
    canvas{width:100%;height:56px;background:var(--chip);border:1px solid var(--stroke);border-radius:10px}

    .cols{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media(max-width:640px){ .cols{grid-template-columns:1fr} }

    .range{display:flex;align-items:center;gap:8px}
    .score-pill{
      font-weight:800;
      padding:10px 14px;
      border-radius:12px;
      background: linear-gradient(90deg, var(--bg2), var(--panel));
      border:1px solid var(--stroke);
      color: var(--text);
      display:inline-block;
      box-shadow: 0 6px 18px rgba(0,0,0,0.06);
      font-size:16px;
    }
    .crit{font-size:13px;color:var(--muted);display:block;margin-top:8px}
    .small{font-size:13px;color:var(--muted)}

    /* Grid spacing increased with --gutter */
    .grid{display:grid;gap:var(--gutter);margin-top:18px;grid-template-columns:1fr}
    /* MAKE TEST PANEL LARGER: left column much wider, right column slimmer */
    @media(min-width:1050px){ .grid{grid-template-columns:1.6fr .4fr} }

    /* part tabs */
    .tabs{display:flex;gap:16px;margin-top:18px}
    .tab-btn{
      padding:10px 16px;border-radius:14px;border:1px solid var(--stroke);background:var(--btn-ghost-bg);color:var(--text);font-weight:800;font-size:15px;cursor:pointer;
    }
    .tab-btn.active{
      background: linear-gradient(90deg,var(--brand),var(--mint));
      color: #fff; border-color: transparent; box-shadow: 0 10px 28px rgba(0,0,0,0.14);
      transform: translateY(-3px);
    }

    aside .pill{padding:8px 12px;font-size:14px}
    .status-muted{ font-size:13px; color:var(--muted) }

    /* Transcript display */
    .transcript-line{margin-top:10px; padding:14px 12px; background:var(--chip); border-radius:12px; border:1px solid var(--stroke); color:var(--text); line-height:1.6; min-height:72px; white-space:pre-wrap; word-break:break-word}
    .suspect{background:var(--suspect-bg); border-bottom:2px solid var(--suspect-border); padding:3px 6px; border-radius:6px; font-weight:800; color:var(--text)}
    .ok{background:var(--ok-bg); border-bottom:2px solid var(--ok-border); padding:3px 6px; border-radius:6px; font-weight:800; color:var(--ok-text)}
    .err{ background: var(--err-bg); border-bottom:2px solid var(--err-border); padding:3px 6px; border-radius:6px; font-weight:800; color:var(--err-text) }
    .misplaced{ background: var(--misplaced-bg); border-bottom:2px solid var(--misplaced-border); padding:3px 6px; border-radius:6px; font-weight:800; color:var(--misplaced-text) }
    .extra{ background: var(--extra-bg); border-bottom:2px solid var(--extra-border); padding:3px 6px; border-radius:6px; font-weight:800; color:var(--extra-text) }

    /* expected/actual small display */
    .aligned-expected, .aligned-actual { margin-top:10px; padding:10px; border-radius:10px; background:var(--chip); border:1px solid var(--stroke); white-space:pre-wrap; word-break:break-word; color:var(--text) }

    /* accuracy badge inside transcript */
    .accuracy-bubble{
      position:relative;
      display:inline-flex;
      align-items:center;
      gap:8px;
      float:right;
      margin: -8px 0 8px 8px;
      background: linear-gradient(180deg,#ffffff22,#ffffff11);
      padding:8px 12px;
      border-radius:999px;
      border:1px solid var(--stroke);
      font-weight:800;
      font-size:14px;
    }

    /* accessibility - focus */
    :focus { outline: 3px solid var(--ring); outline-offset:3px; border-radius:12px; }

    /* subtle responsive tweaks */
    @media(max-width:1050px){
      .head{padding:10px 16px}
      .wrap{padding:18px}
      .card{padding:16px}
      .tabs{gap:10px}
      .accuracy-bubble{float:none; display:block; margin:8px 0}
      .timer{font-size:22px}
    }

    /* small helpers */
    .ref-row{margin-top:12px; display:flex; gap:12px; align-items:flex-start}
    .ref-area{min-height:72px; font-size:14px; padding:10px; border-radius:12px}
    .token { margin-right:6px; display:inline-block; padding:4px 8px; border-radius:8px; font-weight:800 }

    /* ----------------- Final-only visibility control ----------------- */
    .final-only { display: none !important; }
    /* when body has data-finalized="true" show final-only elements */
    body[data-finalized="true"] .final-only { display: initial !important; }

    /* ----------------- Intro card styles ----------------- */
    .intro {
      display:block;
      margin-bottom:18px;
      border-radius:16px;
      padding:20px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid var(--stroke);
    }
    .intro .title { font-size:20px; font-weight:800; margin:0 0 8px 0; }
    .intro .desc { color:var(--muted); margin:0 0 12px 0; font-size:14px }
    .intro .grid-form { display:grid; grid-template-columns:1fr 1fr; gap:12px; }
    @media(max-width:700px){ .intro .grid-form{ grid-template-columns:1fr } }
    .intro input, .intro select { width:100%; padding:10px 12px; border-radius:10px; border:1px solid var(--stroke); background:var(--chip); color:var(--text); }
    .intro .tips { margin-top:12px; color:var(--muted); font-size:14px; line-height:1.5; }
    .intro .start-row{ display:flex; gap:12px; margin-top:16px; align-items:center }
    .locked { opacity: .6; pointer-events: none; }

    /* ----------------- Tidy button layout inside test header/controls ----------------- */
    .section .head .controls {
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    /* make primary controls larger and uniform */
    .section .head .btn {
      min-width:120px;
      padding:10px 14px;
      font-size:14px;
      border-radius:12px;
      flex: none;
    }
    /* group smaller ghost buttons together */
    .section .head .btn.ghost { padding:8px 12px; min-width:92px; }

    /* Make part-record buttons clearer */
    [data-rec] { min-width:160px; padding:12px 16px; font-weight:800; border-radius:12px; }

    /* Make tabs and left panel visually heavier for emphasis */
    #test { box-shadow: 0 14px 40px rgba(0,0,0,0.15); border-radius:16px; }
    #resultsPanel { position:sticky; top:84px; }

  </style>
</head>
<body data-finalized="false">
  <header>
    <div class="head">
      <div class="logo" aria-label="Logo">
        <span class="dot" aria-hidden="true"></span>
        <div>
          <h1>IELTS Speaking ‚Äî Pro Test</h1>
          <div class="sub">Avto-baholash: Fluency / Lexical / Grammar / Pronunciation + PNG eksport</div>
        </div>
      </div>
      <div class="spacer"></div>
      <button id="btnTheme" class="btn ghost" title="Light/Dark">üåì Tema</button>
      <button id="btnPrint" class="btn ghost">üñ®Ô∏è Chop etish</button>
    </div>
  </header>

  <main class="wrap">
    <!-- INTRO: candidate details + tips + Start Test button -->
    <section class="intro card" id="introCard" aria-label="Kirish - ma'lumotlar">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
        <div>
          <div class="title">Kirish: Speaking ma'lumotlari</div>
          <div class="desc">Iltimos imtihonchi haqidagi ma'lumotlarni kiriting. "Start Test" bosilgandan keyin test paneliga o'tasiz.</div>
        </div>
        <div style="text-align:right">
          <div class="small" style="color:var(--muted)">Tartibli va aniq ma'lumotlar natijani kuzatishda yordam beradi.</div>
        </div>
      </div>

      <div class="grid-form" style="margin-top:12px">
        <div>
          <label class="label">Ism, Familiya</label>
          <input id="candidateName" placeholder="Masalan: Alijon Akbarov" />
        </div>
        <div>
          <label class="label">ID / Roll raqami (ixtiyoriy)</label>
          <input id="candidateID" placeholder="Masalan: 2025-0042" />
        </div>
        <div>
          <label class="label">Test sanasi</label>
          <input id="testDate" type="date" />
        </div>
        <div>
          <label class="label">Maqsad band</label>
          <select id="targetBand">
            <option value="">Tanlang (ixtiyoriy)</option>
            <option>Band 6</option>
            <option>Band 6.5</option>
            <option>Band 7</option>
            <option>Band 7.5</option>
            <option>Band 8+</option>
          </select>
        </div>
      </div>

      <div class="tips">
        <strong>Foydali maslahatlar:</strong>
        <ul style="margin:8px 0 0 18px; color:var(--muted)">
          <li>Yozuvdan oldin mikrofonni tekshiring (Mic test).</li>
          <li>Har bir partni alohida yozing ‚Äî oxirida natijalar avtomatik hisoblanadi.</li>
          <li>Qo'shimcha: "Expected text" maydoniga javob namunangizni joylashtirib taqqoslashingiz mumkin.</li>
        </ul>
      </div>

      <div class="start-row">
        <button id="btnStartTest" class="btn ok">‚ñ∂Ô∏è Start Test</button>
        <button id="btnStartTestNoMic" class="btn ghost">‚ñ∂Ô∏è Iltimos, mikrofon yo'q ‚Äî davom etish</button>
        <div class="spacer"></div>
        <div style="display:flex;gap:8px">
          <button id="btnLoadSample" class="btn ghost">üìö Sample Qs</button>
          <button id="btnClearIntro" class="btn ghost">‚úñ Clear</button>
        </div>
      </div>
    </section>

    <div class="grid">
      <!-- TEST PANEL: hidden until "Start Test" clicked -->
      <section class="card" id="test" aria-live="polite" style="display:none">
        <h2 style="font-size:22px; margin-bottom:6px">Test paneli</h2>

        <!-- PART TABS -->
        <div class="tabs" role="tablist" aria-label="Parts tabs">
          <button class="tab-btn active" data-target="p1" role="tab" aria-selected="true">Part 1</button>
          <button class="tab-btn" data-target="p2" role="tab" aria-selected="false">Part 2</button>
          <button class="tab-btn" data-target="p3" role="tab" aria-selected="false">Part 3</button>
        </div>

        <p class="muted" style="margin-top:10px">Mikrofonga ruxsat bering, keyin <b>Start</b> yoki har bir part uchun ‚è∫Ô∏è tugmasini bosing. Hotkeys: Space ‚Äî toggle record.</p>

        <div class="section" aria-hidden="false">
          <div class="head row" style="align-items:center; justify-content:space-between;">
            <div style="display:flex; gap:14px; align-items:center;">
              <div class="timer" id="globalTimer">00:00</div>
              <span class="pill" id="phasePill">Standby</span>
            </div>

            <div class="controls" style="display:flex; gap:10px; align-items:center;">
              <label class="label" for="langSelect" style="margin-right:6px">SR til:</label>
              <select id="langSelect" class="pill" style="padding:8px;border-radius:10px;background:transparent;border:1px solid var(--stroke);color:var(--text); min-width:160px">
                <option value="en-US" selected>English (US)</option>
                <option value="en-GB">English (UK)</option>
                <option value="uz-UZ">O'zbekcha (agar qo'llab-quvvatlansa)</option>
                <option value="ru-RU">–†—É—Å—Å–∫–∏–π</option>
              </select>

              <button id="btnSetup" class="btn">üéôÔ∏è Mic test</button>
              <button id="btnStart" class="btn ok">‚ñ∂Ô∏è Start</button>
              <button id="btnStop" class="btn danger" disabled>‚èπÔ∏è Stop</button>
              <button id="btnReset" class="btn ghost">‚Ü∫ Reset</button>
              <!-- Visible only when all parts completed -->
              <button id="btnShowResults" class="btn ok final-only" style="display:none; margin-left:8px">‚úÖ Ko'rsatish: Natijalar</button>
            </div>
          </div>

          <div class="body">
            <div class="row" style="align-items:flex-start">
              <div style="flex:1;min-width:320px">
                <div class="label">Ovoz darajasi</div>
                <div class="meter" style="margin-bottom:8px;"><div class="bar" id="levelBar" style="height:100%;width:0%;background:linear-gradient(90deg,var(--brand),var(--mint));"></div></div>
                <canvas id="liveWave" height="56" aria-hidden="true"></canvas>
              </div>
              <div style="min-width:340px; max-width:420px;">
                <div class="label">Rejim</div>
                <div class="list" style="display:flex;gap:10px;flex-wrap:wrap;margin-top:8px">
                  <span class="pill" id="micStatus">Mic: unknown</span>
                  <span class="pill" id="recStatus">Rec: idle</span>
                  <button id="btnExportTxt" class="btn ghost" title="Export transcript" style="padding:8px 10px;font-weight:700">üíæ TXT</button>
                </div>
                <div class="small" style="margin-top:12px">SpeechRecognition: <span id="srStatus">unsupported</span></div>

                <div style="margin-top:16px; display:flex; gap:8px; flex-wrap:wrap;">
                  <button class="btn" data-rec="p1">‚è∫Ô∏è Record Part 1</button>
                  <button class="btn" data-rec="p2">‚è∫Ô∏è Record Part 2</button>
                  <button class="btn" data-rec="p3">‚è∫Ô∏è Record Part 3</button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- P1 -->
        <div class="section" id="p1" aria-hidden="false" style="display:block">
          <div class="head row">
            <strong style="font-size:16px">Part 1 ‚Äî Introduction</strong>
            <div style="display:flex; align-items:center; gap:10px">
              <span class="pill final-only" id="p1Score">‚Äî</span>
            </div>
          </div>
          <div class="body">
            <div class="qa" id="p1Qs">Savollar...</div>

            <div class="accuracy-bubble final-only" id="p1AccBubble" style="display:none"><span id="p1AccPct">0%</span> Accuracy</div>
            <div class="transcript-line" id="p1Transcript" aria-live="polite" role="log"></div>

            <div class="ref-row">
              <textarea id="p1Ref" class="ref-area" placeholder="Expected text (paste the correct/reference sentence here)"></textarea>
              <div style="display:flex;flex-direction:column;gap:8px">
                <button class="btn" data-compare="p1">üîé Compare</button>
                <button class="btn ghost" data-clear="p1">‚úñ Clear</button>
              </div>
            </div>

            <div class="aligned-expected final-only" id="p1Expected" style="display:none"></div>
            <div class="aligned-actual final-only" id="p1Actual" style="display:none; margin-top:8px"></div>

            <div class="audio-row" style="margin-top:12px">
              <audio id="p1Audio" controls></audio>
              <a id="p1Dl" class="btn ghost" download>‚¨áÔ∏è Yuklab olish</a>
              <canvas id="p1Wave" height="56" aria-hidden="true"></canvas>
            </div>
            <div class="crit final-only" id="p1Crit"></div>
          </div>
        </div>

        <!-- P2 -->
        <div class="section" id="p2" aria-hidden="true" style="display:none">
          <div class="head row">
            <strong style="font-size:16px">Part 2 ‚Äî Long Turn</strong>
            <div style="display:flex; align-items:center; gap:10px">
              <span class="pill final-only" id="p2Score">‚Äî</span>
            </div>
          </div>
          <div class="body">
            <div class="question big prep" id="p2Card">Cue Card‚Ä¶</div>

            <div class="accuracy-bubble final-only" id="p2AccBubble" style="display:none"><span id="p2AccPct">0%</span> Accuracy</div>
            <div class="transcript-line" id="p2Transcript" aria-live="polite" role="log"></div>

            <div class="ref-row">
              <textarea id="p2Ref" class="ref-area" placeholder="Expected text for Part 2 (short summary)"></textarea>
              <div style="display:flex;flex-direction:column;gap:8px">
                <button class="btn" data-compare="p2">üîé Compare</button>
                <button class="btn ghost" data-clear="p2">‚úñ Clear</button>
              </div>
            </div>

            <div class="aligned-expected final-only" id="p2Expected" style="display:none"></div>
            <div class="aligned-actual final-only" id="p2Actual" style="display:none; margin-top:8px"></div>

            <textarea id="p2Notes" placeholder="Eslatmalar" style="margin-top:12px"></textarea>
            <div class="audio-row" style="margin-top:12px"><audio id="p2Audio" controls></audio><a id="p2Dl" class="btn ghost" download>‚¨áÔ∏è Yuklab olish</a><canvas id="p2Wave" height="56" aria-hidden="true"></canvas></div>
            <div class="crit final-only" id="p2Crit"></div>
          </div>
        </div>

        <!-- P3 -->
        <div class="section" id="p3" aria-hidden="true" style="display:none">
          <div class="head row">
            <strong style="font-size:16px">Part 3 ‚Äî Discussion</strong>
            <div style="display:flex; align-items:center; gap:10px">
              <span class="pill final-only" id="p3Score">‚Äî</span>
            </div>
          </div>
          <div class="body">
            <div class="qa" id="p3Qs">Savollar...</div>

            <div class="accuracy-bubble final-only" id="p3AccBubble" style="display:none"><span id="p3AccPct">0%</span> Accuracy</div>
            <div class="transcript-line" id="p3Transcript" aria-live="polite" role="log"></div>

            <div class="ref-row">
              <textarea id="p3Ref" class="ref-area" placeholder="Expected text for Part 3"></textarea>
              <div style="display:flex;flex-direction:column;gap:8px">
                <button class="btn" data-compare="p3">üîé Compare</button>
                <button class="btn ghost" data-clear="p3">‚úñ Clear</button>
              </div>
            </div>

            <div class="aligned-expected final-only" id="p3Expected" style="display:none"></div>
            <div class="aligned-actual final-only" id="p3Actual" style="display:none; margin-top:8px"></div>

            <div class="audio-row" style="margin-top:12px"><audio id="p3Audio" controls></audio><a id="p3Dl" class="btn ghost" download>‚¨áÔ∏è Yuklab olish</a><canvas id="p3Wave" height="56" aria-hidden="true"></canvas></div>
            <div class="crit final-only" id="p3Crit"></div>
          </div>
        </div>
      </section>

      <!-- RESULTS PANEL: hidden (final-only) until finalized -->
      <aside class="card final-only" id="resultsPanel" style="display:block">
        <h2>Natijalar & Eksport</h2>
        <p class="muted">Avtomatik baholash ‚Äî faqat amaliy qo‚Äòllanma sifatida qarang.</p>

        <div class="section">
          <div class="head"><strong>Baholar</strong></div>
          <div class="body">
            <div class="row" style="justify-content:space-between"><div>Part 1:</div><div class="pill" id="r_p1">‚Äî</div></div>
            <div class="row" style="justify-content:space-between;margin-top:10px"><div>Part 2:</div><div class="pill" id="r_p2">‚Äî</div></div>
            <div class="row" style="justify-content:space-between;margin-top:10px"><div>Part 3:</div><div class="pill" id="r_p3">‚Äî</div></div>
            <div style="margin-top:16px" class="row"><div>Overall Speaking Avg:</div><div class="score-pill" id="avgOverall">‚Äî</div></div>
            <div class="small" style="margin-top:12px">Mezonlar: Fluency / Lexical / Grammar / Pronunciation</div>

            <div style="margin-top:18px" class="row">
              <button id="btnExportSession" class="btn">üßæ Seans JSON</button>
              <button id="btnExportAll" class="btn">üì¶ Hammasini ZIP</button>
              <button id="btnExportPNG" class="btn ghost">üñºÔ∏è Export Result PNG</button>
            </div>

            <div style="margin-top:12px" class="row">
              <button id="btnFinalize" class="btn ok final-only" style="display:none">üîí Locked (results shown)</button>
            </div>
            <div id="finalNote" class="small" style="margin-top:10px;color:var(--muted)"></div>
          </div>
        </div>
      </aside>
    </div>
  </main>

  <!-- external libs -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <script>
    /***********************
     * Utilities & State
     ***********************/
    const el = id => document.getElementById(id);
    const parts = ['p1','p2','p3'];
    const state = {
      stream: null,
      recorder: null,
      chunks: [],
      files: {p1:null,p2:null,p3:null},
      currentPart: 'p1',
      audioCtx: null,
      analyser: null,
      dataArray: null,
      recognition: null,
      // transcripts now store final accumulated + interim stored separately
      transcripts: {p1:'', p2:'', p3:''},
      interim: {p1:'', p2:'', p3:''},
      scores: {p1:null,p2:null,p3:null},
      session: {},
      locked: false // once results shown, lock further testing
    };
    const pad = n => String(n).padStart(2,'0');
    const fmt = s => `${pad(Math.floor(s/60))}:${pad(Math.floor(s%60))}`;

    /***********************
     * Theme handling
     ***********************/
    const root = document.documentElement;
    const btnTheme = el('btnTheme');
    function applyTheme(theme){
      root.setAttribute('data-theme', theme);
      localStorage.setItem('pref-theme', theme);
      btnTheme.textContent = theme === 'light' ? 'üåû Light' : 'üåô Dark';
    }
    (function initTheme(){
      const saved = localStorage.getItem('pref-theme');
      applyTheme(saved || 'dark');
    })();
    btnTheme.addEventListener('click', ()=> {
      const cur = root.getAttribute('data-theme') === 'light' ? 'light' : 'dark';
      const next = cur === 'light' ? 'dark' : 'light';
      applyTheme(next);
      parts.forEach(p => { if(state.files[p]) drawRecordedWave(state.files[p], p); });
    });

    el('btnPrint').addEventListener('click', () => window.print());

    /***********************
     * Intro -> Test flow
     ***********************/
    const introCard = el('introCard');
    const testSection = el('test');
    const btnStartTest = el('btnStartTest');
    const btnStartTestNoMic = el('btnStartTestNoMic');
    const btnLoadSample = el('btnLoadSample');
    const btnClearIntro = el('btnClearIntro');

    btnStartTest.addEventListener('click', async () => {
      // ensure mic available or at least allow setup
      try{
        await navigator.mediaDevices.getUserMedia({audio:true});
      }catch(e){
        if(!confirm('Mikrofonga ruxsat yo\'q yoki bloklangan. Davom etishni xohlaysizmi?')) return;
      }
      introCard.style.display = 'none';
      testSection.style.display = 'block';
      // initialize mic if not yet
      if(!state.stream){ try{ await setupMic(); }catch(e){} }
    });
    btnStartTestNoMic.addEventListener('click', ()=> {
      introCard.style.display = 'none';
      testSection.style.display = 'block';
    });
    btnLoadSample.addEventListener('click', ()=> {
      el('p1Qs').innerHTML = '<div class="question">What do you do in your free time?</div><div class="question">Do you prefer mornings or evenings?</div>';
      el('p2Card').textContent = 'Describe a memorable journey you had. You should say: where you went, how you traveled, and explain why it was memorable.';
      el('p3Qs').innerHTML = '<div class="question">How has technology changed communication?</div><div class="question">What makes a city livable?</div>';
      alert('Sample questions loaded.');
    });
    btnClearIntro.addEventListener('click', ()=> {
      el('candidateName').value=''; el('candidateID').value=''; el('testDate').value=''; el('targetBand').value='';
    });

    /***********************
     * Show/hide parts (tabs)
     ***********************/
    const tabButtons = document.querySelectorAll('.tab-btn');
    function showPart(part){
      parts.forEach(p=>{
        const node = el(p);
        if(!node) return;
        if(p === part){
          node.style.display = 'block';
          node.setAttribute('aria-hidden','false');
        } else {
          node.style.display = 'none';
          node.setAttribute('aria-hidden','true');
        }
      });
      tabButtons.forEach(btn=>{
        const t = btn.getAttribute('data-target');
        if(t === part){ btn.classList.add('active'); btn.setAttribute('aria-selected','true'); }
        else { btn.classList.remove('active'); btn.setAttribute('aria-selected','false'); }
      });
      state.currentPart = part;
    }
    tabButtons.forEach(btn=>{ btn.addEventListener('click', ()=> {
      if(state.locked) return; // prevent switching after locked
      showPart(btn.getAttribute('data-target'));
    }); });
    showPart(state.currentPart || 'p1');

    /***********************
     * Mic & Visualiser
     ***********************/
    async function setupMic(){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({audio:true});
        state.stream = stream;
        el('micStatus').textContent = 'Mic: OK';
        state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const src = state.audioCtx.createMediaStreamSource(stream);
        state.analyser = state.audioCtx.createAnalyser();
        state.analyser.fftSize = 512;
        src.connect(state.analyser);
        state.dataArray = new Uint8Array(state.analyser.frequencyBinCount);
        drawLive();
        initSpeechRecognition();
      }catch(e){
        console.error(e);
        alert('Mikrofon ruxsat etilmadi. Brauzer sozlamalarini tekshiring.');
        el('micStatus').textContent = 'Mic: blocked';
      }
    }

    let liveAnim = null;
    function drawLive(){
      const c = el('liveWave');
      const ctx = c.getContext('2d');
      const w = c.width = c.clientWidth;
      const h = c.height = c.clientHeight;
      if(!state.analyser){ ctx.clearRect(0,0,w,h); return; }
      state.analyser.getByteTimeDomainData(state.dataArray);
      ctx.clearRect(0,0,w,h);
      ctx.lineWidth = 2;
      ctx.strokeStyle = getComputedStyle(document.body).color;
      ctx.beginPath();
      const slice = w / state.dataArray.length;
      let maxAmp = 0;
      for(let i=0;i<state.dataArray.length;i++){
        const x = i*slice;
        const v = (state.dataArray[i]-128)/128;
        const y = h/2 + v*(h/2.2);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        if(Math.abs(v) > maxAmp) maxAmp = Math.abs(v);
      }
      ctx.stroke();
      // level bar
      const lvl = Math.min(1, maxAmp*1.6);
      el('levelBar').style.width = (lvl*100).toFixed(1) + '%';
      liveAnim = requestAnimationFrame(drawLive);
    }

    /***********************
     * Recorder & SpeechRecognition
     ***********************/
    function createRecorder(){
      if(!state.stream) throw new Error('No stream');
      const opts = { mimeType: 'audio/webm' };
      const rec = new MediaRecorder(state.stream, MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? {mimeType:'audio/webm;codecs=opus'} : opts);
      rec.ondataavailable = e => { if(e.data && e.data.size>0) state.chunks.push(e.data); };
      return rec;
    }

    function startRecording(part){
      if(state.locked){ alert('Test yakunlandi ‚Äî natijalarga qaytish mumkin emas.'); return false; }
      if(!state.stream){ alert('Avval Mic test bosing'); return false; }
      if(state.recorder && state.recorder.state === 'recording'){ console.warn('Already recording'); return false; }
      state.chunks = [];
      state.recorder = createRecorder();
      state.recorder.start();
      el('recStatus').textContent = 'Rec: recording';
      el('recStatus').setAttribute('aria-live','polite');
      el('recStatus').setAttribute('role','status');
      // ensure SR language matches selector
      if(state.recognition){
        state.recognition.lang = document.getElementById('langSelect').value || 'en-US';
        try{ state.recognition.start(); }catch(e){ /* ignore start errors */ }
      }
      el('recStatus').textContent = 'Rec: recording';
      return true;
    }

    function stopRecording(part){
      return new Promise(resolve=>{
        if(!state.recorder) return resolve(null);
        const rec = state.recorder;
        if(rec.state !== 'recording') return resolve(null);
        rec.onstop = async () => {
          el('recStatus').textContent = 'Rec: saved';
          const blob = new Blob(state.chunks, { type: 'audio/webm' });
          state.files[part] = blob;
          const url = URL.createObjectURL(blob);
          const audioEl = el(part + 'Audio'); if(audioEl){ audioEl.src = url; audioEl.load(); }
          const dl = el(part + 'Dl'); if(dl){ dl.href = url; dl.download = `${new Date().toISOString().slice(0,19).replace(/[:T]/g,'_')}_${part}.webm`; }
          if(state.recognition){ try{ state.recognition.stop(); }catch(e){} }
          // before scoring: take accumulated transcripts[part] and clean it, update UI
          try{
            // derive cleaned text (best-effort)
            const raw = (state.transcripts[part] || '').trim();
            const cleaned = cleanTranscript(raw || '');
            // update state.transcripts with cleaned version (so scoring uses cleaned)
            state.transcripts[part] = cleaned;
            // show in transcript area (plain text with suspect highlighted)
            renderTranscriptArea(part, cleaned);
          }catch(e){ console.warn('cleaning failed', e); }
          try{ await analyzeBlobAndScore(blob, part, state.transcripts[part]); }catch(e){ console.error('Analyze error', e); }
          try{ await drawRecordedWave(blob, part); }catch(e){ console.warn('draw wave fail', e); }
          state.recorder = null;
          updateFinalizeAvailability();
          resolve(blob);
        };
        try{ rec.stop(); }catch(e){ console.error(e); resolve(null); }
      });
    }

    function initSpeechRecognition(){
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if(!SpeechRecognition){ el('srStatus').textContent = 'unsupported'; return; }
      el('srStatus').textContent = 'available';
      const recog = new SpeechRecognition();
      // Improvements: use many alternatives, continuous, interim results
      recog.interimResults = true;
      recog.continuous = true;
      recog.maxAlternatives = 10;
      recog.lang = document.getElementById('langSelect') ? document.getElementById('langSelect').value : 'en-US';

      recog.onresult = (ev) => {
        // capture both interim and final text; keep per-part context
        let interimParts = [];
        let finals = [];
        for(let i=0;i<ev.results.length;i++){
          const res = ev.results[i];
          if(res.isFinal) finals.push(res[0].transcript);
          else interimParts.push(res[0].transcript);
        }
        const p = state.currentPart || 'p1';
        if(finals.length){
          // append finals to accumulated transcript
          const finalsJoin = finals.join(' ').trim();
          if(finalsJoin) state.transcripts[p] = (state.transcripts[p] + ' ' + finalsJoin).trim();
        }
        // show interim separately (will be combined visually but not stored permanently)
        state.interim[p] = interimParts.join(' ').trim();
        // update visible transcript area live (combine final + interim)
        const combined = ((state.transcripts[p] || '') + ' ' + (state.interim[p] || '')).trim();
        renderTranscriptArea(p, combined, true);
      };

      recog.onerror = (e)=>{ console.warn('SR error', e); };
      recog.onend = ()=>{
        // auto-restart SR while recording to improve continuous capture (some browsers stop)
        try{
          if(state.recorder && state.recorder.state === 'recording'){
            // small delay to avoid immediate loop
            setTimeout(()=>{ try{
              recog.lang = document.getElementById('langSelect') ? document.getElementById('langSelect').value : recog.lang;
              recog.start();
            }catch(e){} }, 250);
          }
        }catch(e){ /* ignore */ }
      };
      state.recognition = recog;

      // If user changes language selection, update live
      const langSel = document.getElementById('langSelect');
      if(langSel){
        langSel.addEventListener('change', ()=> {
          if(state.recognition){
            try{ state.recognition.lang = langSel.value; }catch(e){/*ignore*/ }
          }
        });
      }
    }

    /***********************
     * Transcript cleaning & rendering + compare
     ***********************/
    const fillerList = ['um','uh','hm','hmm','erm','ah','oh','uhm','uhh','ermm','ahh','ohh','mmm','er','like'];

    function normalizeWhitespace(s){ return s.replace(/\s+/g,' ').trim(); }
    function collapseRepeatedWords(text){ return text.replace(/\b([A-Za-z']+)(\s+\1\b)+/gi, '$1'); }
    function collapseRepeatedPhrases(text){
      if(!text) return text;
      const words = text.split(/\s+/).filter(Boolean);
      const n = words.length;
      if(n < 12) return text;
      let out = words.slice();
      for(let seqLen = Math.min(60, Math.floor(n/2)); seqLen>=6; seqLen--){
        let i=0;
        while(i + seqLen*2 <= out.length){
          let match = true;
          for(let k=0;k<seqLen;k++){
            if(out[i+k].toLowerCase() !== out[i+seqLen+k].toLowerCase()){ match=false; break; }
          }
          if(match){ out.splice(i+seqLen, seqLen); } else i++;
        }
      }
      return out.join(' ');
    }
    function removeLongNgramRepeats(text){
      if(!text) return text;
      const words = text.split(/\s+/).filter(Boolean);
      const freq = {};
      for(let n=3;n<=8;n++){
        for(let i=0;i+n<=words.length;i++){
          const key = words.slice(i,i+n).join(' ').toLowerCase();
          freq[key] = (freq[key]||0) + 1;
        }
      }
      const toRemove = new Set();
      Object.keys(freq).forEach(k=>{ if(freq[k] >= 3 && k.replace(/\s+/g,'').length >= 12) toRemove.add(k); });
      if(toRemove.size === 0) return text;
      let outText = text;
      toRemove.forEach(ng=>{ const re = new RegExp('\\b' + escapeRegExp(ng) + '\\b', 'gi'); let count=0; outText = outText.replace(re, (m)=>{ count++; return count===1 ? m : ''; }); });
      return normalizeWhitespace(outText);
    }
    function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

    function cleanTranscript(raw){
      if(!raw) return '';
      let t = raw;
      t = t.replace(/[\u200B-\u200D\uFEFF]/g,'');
      t = t.replace(/(https?:\/\/\S+)/gi,'');
      t = t.replace(/[^ -~\n\r\t]/g,' ');
      t = normalizeWhitespace(t);
      t = collapseRepeatedWords(t);
      t = collapseRepeatedPhrases(t);
      t = removeLongNgramRepeats(t);
      t = t.replace(/(.)\1{8,}/g,'');
      t = t.replace(/\b(in|of|and|the|a|to|for|on|my)\b\s*$/i, '');
      t = normalizeWhitespace(t);
      return t;
    }

    function isSuspectWord(w, freqMap){
      if(!w) return false;
      const clean = w.replace(/[^\w'-]/g,'');
      if(clean.length === 0) return true;
      if(clean.length > 25) return true;
      if(/(.)\1{5,}/i.test(clean)) return true;
      if(fillerList.includes(clean.toLowerCase())) return true;
      if(freqMap[clean.toLowerCase()] && freqMap[clean.toLowerCase()] > 25) return true;
      if(/[0-9]/.test(clean) && clean.length < 3) return true;
      return false;
    }

    // Levenshtein DP to get edit operations between actual (aTokens) and expected (bTokens)
    function getEditOps(aTokens, bTokens){
      const n = aTokens.length, m = bTokens.length;
      const dp = Array.from({length: n+1}, ()=> new Array(m+1).fill(0));
      const op = Array.from({length: n+1}, ()=> new Array(m+1).fill(null));
      for(let i=0;i<=n;i++){ dp[i][0] = i; op[i][0] = 'del'; }
      for(let j=0;j<=m;j++){ dp[0][j] = j; op[0][j] = 'ins'; }
      dp[0][0] = 0; op[0][0] = null;
      for(let i=1;i<=n;i++){
        for(let j=1;j<=m;j++){
          const equal = aTokens[i-1].toLowerCase() === bTokens[j-1].toLowerCase();
          const subCost = dp[i-1][j-1] + (equal ? 0 : 1);
          const delCost = dp[i-1][j] + 1; // delete a[i-1] (extra)
          const insCost = dp[i][j-1] + 1; // insert b[j-1] (missing in actual)
          dp[i][j] = subCost;
          op[i][j] = equal ? 'match' : 'sub';
          if(delCost < dp[i][j]){ dp[i][j] = delCost; op[i][j] = 'del'; }
          if(insCost < dp[i][j]){ dp[i][j] = insCost; op[i][j] = 'ins'; }
        }
      }
      // backtrace
      let i = n, j = m;
      const ops = [];
      while(i>0 || j>0){
        const c = op[i][j];
        if(c === 'match' || c === 'sub'){
          ops.push({op: c === 'match' ? 'match' : 'sub', a: aTokens[i-1], b: bTokens[j-1]});
          i--; j--;
        } else if(c === 'del'){
          ops.push({op: 'extra', a: aTokens[i-1], b: ''});
          i--;
        } else if(c === 'ins'){
          ops.push({op: 'missing', a: '', b: bTokens[j-1]});
          j--;
        } else {
          // fallback
          if(i>0){ ops.push({op:'extra', a: aTokens[i-1], b: ''}); i--; }
          else if(j>0){ ops.push({op:'missing', a:'', b: bTokens[j-1]}); j--; }
        }
      }
      ops.reverse();
      return ops;
    }

    // Compare & render with misplaced detection
    function compareAndRender(part, actualText, expectedText){
      const actualTokens = actualText ? actualText.trim().split(/\s+/).filter(Boolean) : [];
      const expectedTokens = expectedText ? expectedText.trim().split(/\s+/).filter(Boolean) : [];

      // build raw ops
      const ops = getEditOps(actualTokens, expectedTokens);

      // counts of unmatched expected and actual (for misplaced detection)
      const unmatchedExpected = {};
      const unmatchedActual = {};
      ops.forEach(e=>{
        if(e.op !== 'match'){
          if(e.b) { const k = e.b.toLowerCase(); unmatchedExpected[k] = (unmatchedExpected[k]||0) + 1; }
          if(e.a) { const k = e.a.toLowerCase(); unmatchedActual[k] = (unmatchedActual[k]||0) + 1; }
        }
      });

      // second pass: transform extras/missing into misplaced when token exists in opposite unmatched map
      const displayExpected = [];
      const displayActual = [];
      let matches = 0, subs = 0, extras = 0, miss = 0, misplaced = 0, total = 0;
      ops.forEach(e=>{
        total++;
        const a = e.a || '';
        const b = e.b || '';
        const aLow = a.toLowerCase();
        const bLow = b.toLowerCase();
        if(e.op === 'match'){
          displayExpected.push(`<span class="token ok">${escapeHtml(b)}</span>`);
          displayActual.push(`<span class="token ok">${escapeHtml(a)}</span>`);
          matches++;
        } else if(e.op === 'sub'){
          // substitution: mark both as err
          displayExpected.push(`<span class="token err">${escapeHtml(b)}</span>`);
          displayActual.push(`<span class="token err">${escapeHtml(a)}</span>`);
          subs++;
        } else if(e.op === 'extra'){
          // actual has extra token a. If that token appears in unmatchedExpected, treat as misplaced.
          if(unmatchedExpected[aLow] && unmatchedExpected[aLow] > 0){
            displayExpected.push(`<span class="token misplaced">${escapeHtml(a)}</span>`);
            displayActual.push(`<span class="token misplaced">${escapeHtml(a)}</span>`);
            unmatchedExpected[aLow]--; // consume one
            misplaced++;
          } else {
            displayExpected.push(`<span class="token err">(extra)</span>`);
            displayActual.push(`<span class="token extra">${escapeHtml(a)}</span>`);
            extras++;
          }
        } else if(e.op === 'missing'){
          // expected token b is missing in actual. If that token exists in unmatchedActual, mark misplaced
          if(unmatchedActual[bLow] && unmatchedActual[bLow] > 0){
            displayExpected.push(`<span class="token misplaced">${escapeHtml(b)}</span>`);
            displayActual.push(`<span class="token misplaced">${escapeHtml(b)}</span>`);
            unmatchedActual[bLow]--;
            misplaced++;
          } else {
            displayExpected.push(`<span class="token err">${escapeHtml(b)}</span>`);
            displayActual.push(`<span class="token err">(missing: ${escapeHtml(b)})</span>`);
            miss++;
          }
        }
      });

      // Render into UI: show expected and actual aligned views for user
      const expectedEl = el(part + 'Expected');
      const actualEl = el(part + 'Actual');
      if(expectedEl && actualEl){
        expectedEl.style.display = 'block';
        actualEl.style.display = 'block';
        expectedEl.innerHTML = '<strong>Expected:</strong><div style="margin-top:6px">' + displayExpected.join(' ') + '</div>';
        actualEl.innerHTML = '<strong>Actual:</strong><div style="margin-top:6px">' + displayActual.join(' ') + '</div>';
      }

      // also mark actual transcript tokens in main transcript area (highlight err/misplaced)
      const mainNode = el(part + 'Transcript');
      if(mainNode){
        mainNode.innerHTML = actualEl.innerHTML;
      }

      // update crit area (counts)
      const crit = el(part + 'Crit');
      if(crit){
        crit.innerHTML = `<span class="small">words compared: ${total} ¬∑ matches: ${matches} ¬∑ substitutions: ${subs} ¬∑ misplaced: ${misplaced} ¬∑ extra: ${extras} ¬∑ missing: ${miss}</span>`;
      }

      // update accuracy bubble
      const accBubble = el(part + 'AccBubble');
      const accPctNode = el(part + 'AccPct');
      if(accBubble && accPctNode){
        const totalWords = actualTokens.length || expectedTokens.length || total;
        const bad = subs + extras + miss + misplaced;
        if(totalWords === 0){ accBubble.style.display = 'none'; accPctNode.textContent = '0%'; }
        else { const pct = Math.round(((totalWords - bad) / Math.max(1, totalWords)) * 100); accBubble.style.display = 'inline-flex'; accPctNode.textContent = pct + '%'; }
      }
    }

    // render transcript into the transcript-line element (live/no-ref)
    function renderTranscriptArea(part, text, live=false){
      const node = el(part + 'Transcript');
      if(!node) return;
      const tokens = (text || '').split(/\s+/).filter(Boolean);
      const freq = {}; tokens.forEach(t=>{ const k=t.toLowerCase(); freq[k]=(freq[k]||0)+1; });

      const frag = document.createDocumentFragment();
      let suspectCount = 0;
      tokens.forEach((w,i)=>{
        const span = document.createElement('span');
        if(isSuspectWord(w, freq)){
          span.className = 'suspect';
          suspectCount++;
        } else {
          span.className = 'ok';
        }
        span.textContent = w;
        frag.appendChild(span);
        if(i < tokens.length - 1) frag.appendChild(document.createTextNode(' '));
      });

      if(tokens.length === 0){
        node.textContent = '(Transcript is empty)';
      } else {
        node.innerHTML = '';
        node.appendChild(frag);
      }

      const crit = el(part + 'Crit');
      const wordsCount = tokens.length;
      if(crit){
        crit.innerHTML = `<span class="small">words: ${wordsCount}${live ? ' ¬∑ (live)' : ''} ¬∑ suspects: ${suspectCount}</span>`;
      }

      const accBubble = el(part + 'AccBubble');
      const accPctNode = el(part + 'AccPct');
      if(accBubble && accPctNode){
        if(wordsCount === 0){ accBubble.style.display = 'none'; accPctNode.textContent = '0%'; }
        else { const pct = Math.round(((wordsCount - suspectCount) / wordsCount) * 100); accBubble.style.display = 'inline-flex'; accPctNode.textContent = pct + '%'; }
      }
    }

    /***********************
     * Analysis helpers (unchanged)
     ***********************/
    async function decodeAudio(blob){
      const arrayBuf = await blob.arrayBuffer();
      const aCtx = state.audioCtx || new (window.AudioContext || window.webkitAudioContext)();
      return await aCtx.decodeAudioData(arrayBuf);
    }
    function rms(buf){ let sum=0; for(let i=0;i<buf.length;i++){ const v=buf[i]; sum += v*v; } return Math.sqrt(sum / buf.length); }

    function detectSilences(samples, sr, thresh = 0.02, minSilenceLen = 0.5){
      const windowMs = 50;
      const winSize = Math.floor(sr * windowMs/1000);
      let totalSilence = 0;
      let longPauses = 0;
      let curSil = 0;
      for(let i=0;i<samples.length;i+=winSize){
        let max = 0;
        for(let j=i;j<Math.min(i+winSize, samples.length); j++){ max = Math.max(max, Math.abs(samples[j])); }
        if(max < thresh){ curSil += winSize/sr; } else { if(curSil >= minSilenceLen) longPauses++; totalSilence += curSil; curSil = 0; }
      }
      if(curSil > 0){ if(curSil >= minSilenceLen) longPauses++; totalSilence += curSil; }
      return { totalSilence, longPauses };
    }

    function voicednessRatio(samples, sr){
      const frameSize = 2048;
      const hop = 1024;
      let voicedFrames = 0, total = 0;
      for(let i=0;i+frameSize < samples.length;i+=hop){
        total++;
        const frame = samples.subarray(i, i+frameSize);
        let m=0; for(let k=0;k<frame.length;k++) m+=frame[k]; m/=frame.length;
        for(let k=0;k<frame.length;k++) frame[k]-=m;
        let maxCorr = 0;
        const minF = 60, maxF = 400;
        const minLag = Math.floor(sr / maxF);
        const maxLag = Math.floor(sr / minF);
        let norm = 0;
        for(let lag=minLag; lag<=maxLag; lag++){
          let s=0;
          for(let j=0;j<frame.length-lag;j++) s += frame[j]*frame[j+lag];
          if(s > maxCorr) maxCorr = s;
        }
        for(let j=0;j<frame.length;j++) norm += frame[j]*frame[j];
        const ratio = norm > 0 ? maxCorr / norm : 0;
        if(ratio > 0.25) voicedFrames++;
      }
      return total ? (voicedFrames / total) : 0;
    }

    function tokenize(text){ if(!text) return []; return text.toLowerCase().replace(/[^\w'\s]/g,' ').split(/\s+/).filter(Boolean); }
    function lexicalMetrics(words){ if(words.length===0) return {TTR:0, vocab:0}; const set = new Set(words); return { TTR: set.size / words.length, vocab: set.size }; }
    function countFillers(words){ let cnt=0; for(let i=0;i<words.length;i++){ if(fillerList.includes(words[i])) cnt++; } return cnt; }
    const to9 = v => Math.max(0, Math.min(9, +(v*9).toFixed(1)));

    /***********************
     * Scoring model (unchanged)
     ***********************/
    async function analyzeBlobAndScore(blob, part, transcriptOverride){
      const audioBuf = await decodeAudio(blob);
      const data = audioBuf.getChannelData(0);
      const sr = audioBuf.sampleRate;
      const duration = audioBuf.duration;
      const energy = rms(data);
      const sil = detectSilences(data, sr, 0.02, 0.6);
      const silenceRatio = duration > 0 ? sil.totalSilence / duration : 0;
      let voicedRatio = 0;
      try{ voicedRatio = voicednessRatio(data, sr); }catch(e){ console.warn('voicedness failed', e); }
      const transcript = (typeof transcriptOverride === 'string' && transcriptOverride.trim()) ? transcriptOverride.trim() : (state.transcripts[part] || '').trim();
      const words = tokenize(transcript);
      const wordCount = words.length;
      const speechRate = duration>0 ? (wordCount / duration) : 0; // words/sec
      const lex = lexicalMetrics(words);
      const fillerCount = countFillers(words);
      const sentenceCount = Math.max(1, (transcript.match(/[.!?]/g)||[]).length || 1);
      const avgWordsPerSentence = wordCount / sentenceCount;

      // Fluency
      const silenceFactor = Math.max(0, 1 - silenceRatio*1.6);
      const pausePenalty = Math.max(0, 1 - Math.min(5, sil.longPauses)/5);
      const rateNorm = Math.max(0, Math.min(1, (speechRate - 1.5) / 3.0));
      const fluencyScore = to9( (silenceFactor*0.6 + pausePenalty*0.2 + rateNorm*0.2) );

      // Lexical
      const ttr = lex.TTR; const vocab = lex.vocab;
      const vocabNorm = Math.min(1, Math.log10(Math.max(1,vocab)) / 1.6);
      const lexicalScore = to9( Math.max(0, Math.min(1, ttr*0.6 + vocabNorm*0.4)) );

      // Grammar
      const awps = avgWordsPerSentence; const awpsScore = Math.max(0, Math.min(1, (awps/12)));
      const fillerPenalty = Math.max(0, 1 - Math.min(wordCount, fillerCount) / Math.max(1, wordCount) * 2);
      const grammarScore = to9( Math.max(0, awpsScore*0.8 + fillerPenalty*0.2) );

      // Pronunciation
      const energyNorm = Math.min(1, energy / 0.1);
      const pronScore = to9( Math.max(0, voicedRatio*0.7 + energyNorm*0.3) );

      const final = +(( (fluencyScore + lexicalScore + grammarScore + pronScore) / 4 ).toFixed(1));

      // Save to state.scores (DOM is hidden until finalize)
      state.scores[part] = {
        fluency: fluencyScore,
        lexical: lexicalScore,
        grammar: grammarScore,
        pronunciation: pronScore,
        final
      };

      // Update per-part crit (kept hidden until finalize)
      const critEl = el(part + 'Crit');
      if(critEl){
        critEl.innerHTML = `
          <strong>Transcript (used):</strong> ${transcript ? ('<em>' + escapeHtml(transcript) + '</em>') : '<em>(no transcript)</em>'}
          <br>
          <span class="small">dur: ${duration.toFixed(1)}s ¬∑ words: ${wordCount} ¬∑ silence: ${(silenceRatio*100).toFixed(1)}% ¬∑ long pauses: ${sil.longPauses} ¬∑ voiced: ${(voicedRatio*100).toFixed(0)}%</span>
        `;
      }

      // we still set textContent for score elements (they are hidden by CSS until finalize)
      const scoreEl = el(part + 'Score');
      if(scoreEl) scoreEl.textContent = final.toFixed(1);
      const rEl = el('r_' + part);
      if(rEl) rEl.textContent = final.toFixed(1);

      computeOverallAndDisplay();
    }

    function computeOverallAndDisplay(){
      const vals = [];
      ['p1','p2','p3'].forEach(p=>{
        const s = state.scores[p];
        if(s && typeof s.final === 'number') vals.push(s.final);
      });
      const overall = vals.length ? (vals.reduce((a,b)=>a+b,0)/vals.length) : null;
      el('avgOverall').textContent = overall ? overall.toFixed(1) : '‚Äî';
      if(overall) state.session.overall = overall;
    }

    /***********************
     * draw recorded wave
     ***********************/
    async function drawRecordedWave(blob, part){
      try{
        const ctx = el(part + 'Wave').getContext('2d');
        const arrayBuf = await blob.arrayBuffer();
        const aCtx = state.audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        const audioBuf = await aCtx.decodeAudioData(arrayBuf);
        const data = audioBuf.getChannelData(0);
        const len = 800;
        const step = Math.max(1, Math.floor(data.length / len));
        const w = ctx.canvas.width = ctx.canvas.clientWidth;
        const h = ctx.canvas.height = ctx.canvas.clientHeight;
        const amp = h/2 - 2;
        ctx.clearRect(0,0,w,h);
        ctx.lineWidth = 2;
        ctx.strokeStyle = getComputedStyle(document.body).color;
        ctx.beginPath();
        for(let i=0;i<len;i++){
          let min=1,max=-1;
          for(let j=0;j<step;j++){
            const idx = i*step + j;
            if(idx >= data.length) break;
            const v = data[idx];
            if(v < min) min = v;
            if(v > max) max = v;
          }
          const x = i * (w/len);
          ctx.moveTo(x, (1 + min) * amp);
          ctx.lineTo(x, (1 + max) * amp);
        }
        ctx.stroke();
      }catch(e){ console.warn('drawRecordedWave err', e); }
    }

    /***********************
     * Buttons & flow
     ***********************/
    el('btnSetup').addEventListener('click', setupMic);

    // Start / Stop global timer + record for current part
    let globalInterval=null, globalStart=0;
    function startGlobal(){
      globalStart = Date.now();
      state.session.startedAt = new Date().toISOString();
      clearInterval(globalInterval);
      globalInterval = setInterval(()=> {
        const s = Math.floor((Date.now() - globalStart)/1000);
        el('globalTimer').textContent = fmt(s);
      },1000);
    }
    function stopGlobal(){
      clearInterval(globalInterval);
      state.session.finishedAt = new Date().toISOString();
    }

    el('btnStart').addEventListener('click', ()=>{
      if(state.locked){ alert('Test yakunlandi ‚Äî natijalarga qaytish mumkin emas.'); return; }
      if(!state.stream){
        if(!confirm('Mikrofon ruxsatisiz davom etilsinmi? (avval Mic test bosing)')) return;
      }
      startGlobal();
      el('phasePill').textContent = 'Recording';
      el('btnStart').disabled = true;
      el('btnStop').disabled = false;
      state.currentPart = state.currentPart || 'p1';
      startRecording(state.currentPart);
    });

    el('btnStop').addEventListener('click', async ()=>{
      if(state.locked){ alert('Test yakunlandi ‚Äî natijalarga qaytish mumkin emas.'); return; }
      if(state.recorder && state.recorder.state === 'recording'){
        const part = state.currentPart || 'p1';
        await stopRecording(part);
      }
      stopGlobal();
      el('phasePill').textContent = 'Stopped';
      el('btnStart').disabled = false;
      el('btnStop').disabled = true;
      alert('Yozuv to‚Äòxtatildi va baholash bajarildi (agar audio bo‚Äòlsa).');
    });

    document.querySelectorAll('[data-rec]').forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        if(state.locked){ alert('Test yakunlandi ‚Äî natijalarga qaytish mumkin emas.'); return; }
        const part = btn.getAttribute('data-rec');
        if(state.recorder && state.recorder.state === 'recording'){
          if(state.currentPart === part){
            await stopRecording(part);
            return;
          } else {
            await stopRecording(state.currentPart);
            state.currentPart = part;
            startRecording(part);
            return;
          }
        } else {
          state.currentPart = part;
          startRecording(part);
          if(!globalInterval){ startGlobal(); el('btnStart').disabled = true; el('btnStop').disabled = false; }
        }
      });
    });

    el('btnReset').addEventListener('click', ()=>{
      if(state.locked){ alert('Test yakunlandi ‚Äî reset mumkin emas.'); return; }
      if(!confirm('Butun sessiyani reset qilinsinmi?')) return;
      if(state.recorder && state.recorder.state === 'recording'){ try{ state.recorder.stop(); }catch(e){} }
      stopGlobal();
      parts.forEach(p=>{
        state.files[p]=null;
        state.transcripts[p]='';
        state.interim[p]='';
        state.scores[p]=null;
        const a = el(p+'Audio'); if(a) a.src='';
        el(p+'Score').textContent = '‚Äî';
        el('r_'+p).textContent = '‚Äî';
        const crit = el(p+'Crit'); if(crit) crit.innerHTML='';
        const c = el(p+'Wave'); if(c) c.getContext('2d').clearRect(0,0,c.width,c.height);
        const tnode = el(p+'Transcript'); if(tnode) tnode.textContent = '';
        const bub = el(p + 'AccBubble'); if(bub) bub.style.display = 'none';
        const pct = el(p + 'AccPct'); if(pct) pct.textContent = '0%';
        const ref = el(p + 'Ref'); if(ref) ref.value = '';
        const exp = el(p + 'Expected'); if(exp) { exp.style.display='none'; exp.innerHTML=''; }
        const act = el(p + 'Actual'); if(act) { act.style.display='none'; act.innerHTML=''; }
      });
      el('globalTimer').textContent = '00:00';
      el('phasePill').textContent = 'Standby';
      el('btnStart').disabled = false;
      el('btnStop').disabled = true;
      el('avgOverall').textContent = '‚Äî';
      state.session = {};
      // hide final-only UI and reset finalize button
      document.body.setAttribute('data-finalized','false');
      state.locked = false;
      updateFinalizeAvailability();
      // enable tabs
      document.querySelectorAll('.tab-btn').forEach(b=> b.classList.remove('locked'));
      document.querySelectorAll('[data-rec]').forEach(b=> b.disabled = false);
      el('btnStart').disabled = false; el('btnStop').disabled = true;
    });

    /***********************
     ***********************/
    el('btnExportTxt').addEventListener('click', ()=>{
      const out = {
        p1: state.transcripts.p1 || '',
        p2: state.transcripts.p2 || '',
        p3: state.transcripts.p3 || ''
      };
      const txt = `Part1:\n${out.p1}\n\nPart2:\n${out.p2}\n\nPart3:\n${out.p3}\n`;
      const blob = new Blob([txt], {type:'text/plain;charset=utf-8'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = `speaking_transcript_${new Date().toISOString().slice(0,10)}.txt`; a.click(); URL.revokeObjectURL(url);
    });

    /***********************
     ***********************/
    el('btnExportSession').addEventListener('click', ()=>{
      state.session.transcripts = state.transcripts; state.session.scores = state.scores;
      const blob = new Blob([JSON.stringify(state.session,null,2)],{type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = `speaking_session_${new Date().toISOString().slice(0,10)}.json`; a.click(); URL.revokeObjectURL(url);
    });

    el('btnExportAll').addEventListener('click', async ()=>{
      const zip = new JSZip();
      zip.file('session.json', JSON.stringify(state.session,null,2));
      for(const p of parts){
        if(state.files[p]) zip.file(`${p}.webm`, state.files[p]);
      }
      const blob = await zip.generateAsync({type:'blob'});
      const url = URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download = `speaking_${new Date().toISOString().slice(0,10)}.zip`; a.click(); URL.revokeObjectURL(url);
    });

    el('btnExportPNG').addEventListener('click', async ()=>{
      try{
        const node = el('resultsPanel');
        el('btnExportPNG').textContent = 'üîÑ Generating...';
        const canvas = await html2canvas(node, {scale:2, useCORS:true, backgroundColor: getComputedStyle(document.body).backgroundColor});
        canvas.toBlob((blob)=>{
          const url = URL.createObjectURL(blob);
          const a=document.createElement('a'); a.href = url; a.download = `speaking_results_${new Date().toISOString().slice(0,10)}.png`; a.click(); URL.revokeObjectURL(url);
          el('btnExportPNG').textContent = 'üñºÔ∏è Export Result PNG';
        }, 'image/png');
      }catch(e){ alert('PNG yaratishda xato: ' + e); el('btnExportPNG').textContent = 'üñºÔ∏è Export Result PNG'; }
    });

    /***********************
     * Finalize / Show Results logic:
     * - btnShowResults appears when all parts completed
     * - clicking it reveals resultsPanel (body[data-finalized]="true"), disables further testing
     ***********************/
    const btnShowResults = el('btnShowResults');
    function allPartsCompleted(){
      return parts.every(p => state.scores[p] && typeof state.scores[p].final === 'number');
    }
    function updateFinalizeAvailability(){
      const note = el('finalNote');
      const showBtn = el('btnShowResults');
      if(allPartsCompleted() && !state.locked){
        // show button to reveal results (outside results panel)
        showBtn.style.display = 'inline-flex';
        showBtn.disabled = false;
        note.textContent = 'Barcha partlar tugadi ‚Äî "Ko\'rsatish: Natijalar" tugmasini bosing.';
      } else {
        showBtn.style.display = 'none';
        const missing = parts.filter(p => !(state.scores[p] && typeof state.scores[p].final === 'number'));
        note.textContent = missing.length ? `Waiting for: ${missing.join(', ')} ‚Äî results hidden until all parts are done.` : '';
      }
    }

    btnShowResults.addEventListener('click', ()=> {
      if(!allPartsCompleted()) return alert('Hali barcha partlar to‚Äòliq emas.');
      // reveal results and lock test UI
      document.body.setAttribute('data-finalized','true');
      state.locked = true;
      // disable recording controls and tab switching
      document.querySelectorAll('.tab-btn').forEach(b=>{ b.classList.add('locked'); b.style.pointerEvents='none'; });
      document.querySelectorAll('[data-rec]').forEach(b=> { b.disabled = true; });
      el('btnStart').disabled = true; el('btnStop').disabled = true; el('btnReset').disabled = true;
      // ensure final-only elements are visible (CSS handles it)
      computeOverallAndDisplay();
      // hide the show results button
      btnShowResults.style.display = 'none';
      el('finalNote').textContent = 'Natijalar ko‚Äòrsatildi va testlar qulflandi ‚Äî testlarga qaytish mumkin emas.';
    });

    /***********************
     ***********************/
    window.addEventListener('keydown', async (e)=>{
      if(e.code === 'Space' && (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA')){
        e.preventDefault();
        if(state.locked){ alert('Test yakunlandi ‚Äî qo\'shimcha yozuvlar qabul qilinmaydi.'); return; }
        if(state.recorder && state.recorder.state === 'recording'){
          const part = state.currentPart || 'p1';
          await stopRecording(part);
        } else {
          const part = state.currentPart || 'p1';
          startRecording(part);
          if(!globalInterval) startGlobal();
          el('btnStart').disabled = true; el('btnStop').disabled = false;
        }
      }
    });

    /***********************
     * Compare & clear handlers
     ***********************/
    function escapeHtml(str){
      return str.replace(/[&<>"']/g, function(m){ return { '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]; });
    }

    setInterval(()=> {
      const p = state.currentPart || 'p1';
      const combined = ((state.transcripts[p] || '') + ' ' + (state.interim[p] || '')).trim();
      const ref = (el(p + 'Ref') && el(p + 'Ref').value) || '';
      const expectedEl = el(p + 'Expected');
      if(ref && expectedEl && expectedEl.style.display === 'block'){
      } else {
        if(combined) renderTranscriptArea(p, combined, !!state.interim[p]);
        else renderTranscriptArea(p, combined, !!state.interim[p]);
      }
    }, 600);

    document.querySelectorAll('[data-compare]').forEach(btn=>{
      btn.addEventListener('click', ()=> {
        const part = btn.getAttribute('data-compare');
        const ref = (el(part + 'Ref').value || '').trim();
        const combined = ((state.transcripts[part] || '') + ' ' + (state.interim[part] || '')).trim();
        compareAndRender(part, combined, ref);
      });
    });
    document.querySelectorAll('[data-clear]').forEach(btn=>{
      btn.addEventListener('click', ()=> {
        const part = btn.getAttribute('data-clear');
        el(part + 'Ref').value = '';
        // hide aligned displays
        const expectedEl = el(part + 'Expected');
        const actualEl = el(part + 'Actual');
        if(expectedEl){ expectedEl.style.display='none'; expectedEl.innerHTML=''; }
        if(actualEl){ actualEl.style.display='none'; actualEl.innerHTML=''; }
        const combined = ((state.transcripts[part] || '') + ' ' + (state.interim[part] || '')).trim();
        renderTranscriptArea(part, combined, false);
      });
    });

    /***********************
     ***********************/
    const observer = new MutationObserver(()=> {
      parts.forEach(p=>{
        const file = state.files[p];
        if(file) drawRecordedWave(file, p);
      });
    });
    observer.observe(root, { attributes: true, attributeFilter: ['data-theme'] });

    /***********************
     ***********************/
    (function genQuestions(){
      el('p1Qs').innerHTML = '<div class="question">What do you do in your free time?</div><div class="question">Do you prefer mornings or evenings?</div>';
      el('p2Card').textContent = 'Describe a memorable journey you had. You should say: where you went, how you traveled, and explain why it was memorable.';
      el('p3Qs').innerHTML = '<div class="question">How has technology changed communication?</div><div class="question">What makes a city livable?</div>';
    })();

    el('srStatus').textContent = (window.SpeechRecognition || window.webkitSpeechRecognition) ? 'available' : 'unsupported';

    (function ensureAccBubbles(){
      parts.forEach(p=>{
        const id = p + 'AccBubble';
        if(!document.getElementById(id)){
        }
      });
    })();

    try{ initSpeechRecognition(); }catch(e){ /* ignore */ }

    // initial finalize availability check
    updateFinalizeAvailability();

  </script>
</body>
</html>






umuman bolmayapti iltimos profisionalikk bilan qilib ber kirish qismida ushbu qilingan speaking ni malumotlari kiritilsin !!! 