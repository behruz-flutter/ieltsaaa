<!doctype html>
<html lang="uz">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>IELTS Speaking ‚Äî Auto-score (with PNG export)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root{ --bg:#0b1020; --bg2:#111736; --panel:#0e1531; --text:#f1f5ff; --muted:#a9b2d3; --brand:#7c9cff; --mint:#5eead4; --stroke:rgba(124,156,255,.25); --chip:#0c1230; --ring:#203060;}
    [data-theme="light"]{ --bg:#f4f6ff; --bg2:#ffffff; --panel:#f6f8ff; --text:#0b1020; --muted:#505a7a; --stroke:rgba(30,50,150,.18); --chip:#eef2ff; --ring:#dfe6ff;}
    *{box-sizing:border-box} html,body{height:100%} body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;color:var(--text);
      background: radial-gradient(1000px 600px at 120% -10%, #18224a22 0%, transparent 55%),
                  radial-gradient(800px 500px at -20% 20%, #15204a22 0%, transparent 55%),
                  linear-gradient(180deg, var(--bg) 0%, var(--bg) 100%);}
    .wrap{max-width:1200px;margin:0 auto;padding:20px}
    header{position:sticky;top:0;z-index:40;background:linear-gradient(180deg,rgba(11,16,32,.9),rgba(11,16,32,.6));backdrop-filter:saturate(115%) blur(8px);border-bottom:1px solid var(--stroke)}
    .head{max-width:1200px;margin:0 auto;padding:12px 20px;display:flex;gap:12px;align-items:center} .logo{display:flex;gap:10px;align-items:center} .dot{width:10px;height:10px;border-radius:50%;background:linear-gradient(135deg,var(--brand),var(--mint));box-shadow:0 0 0 5px rgba(124,156,255,.15)} h1{font-size:clamp(18px,3vw,28px);margin:0} .sub{font-size:12px;color:var(--muted)} .spacer{flex:1}
    .btn{background:linear-gradient(180deg,#1a2250,#151c3f);color:var(--text);border:1px solid var(--stroke);padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer}
    .btn.ghost{background:var(--chip)} .btn.danger{background:linear-gradient(180deg,#3a1420,#2a0e18)} .btn.ok{background:linear-gradient(180deg,#123922,#0d2d1a)}
    .grid{display:grid;gap:16px;margin-top:18px;grid-template-columns:1fr} @media(min-width:1050px){.grid{grid-template-columns:1.15fr .85fr}}
    .card{background:linear-gradient(180deg,var(--bg2),var(--panel));border:1px solid var(--stroke);border-radius:16px;padding:16px} .muted{color:var(--muted);font-size:13px;margin:0}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center} .label{font-size:12px;color:var(--muted)}
    .meter{height:10px;background:#0b1232;border:1px solid var(--stroke);border-radius:999px;overflow:hidden}
    .timer{font-variant-numeric:tabular-nums;font-size:28px;font-weight:800} .pill{font-size:12px;padding:4px 10px;border-radius:999px;border:1px solid var(--stroke);background:var(--chip)}
    .section{border:1px solid var(--stroke);background:var(--panel);border-radius:14px;margin-top:10px}
    .section .head{padding:12px 14px} .section .body{padding:12px 14px;border-top:1px solid var(--stroke)}
    .qa{display:grid;gap:10px} .question{padding:10px 12px;border:1px solid var(--stroke);background:var(--chip);border-radius:12px;position:relative}
    textarea{width:100%;min-height:90px;border-radius:12px;border:1px solid var(--stroke);background:var(--chip);color:var(--text);padding:10px}
    .audio-row{display:flex;gap:10px;align-items:center;flex-wrap:wrap} audio{width:100%}
    canvas{width:100%;height:46px;background:var(--chip);border:1px solid var(--stroke);border-radius:10px}
    .cols{display:grid;grid-template-columns:1fr 1fr;gap:10px} @media(max-width:640px){.cols{grid-template-columns:1fr}}
    .range{display:flex;align-items:center;gap:8px} input[type="range"]{width:160px}
    .score-pill{font-weight:800;padding:6px 10px;border-radius:10px;background:linear-gradient(90deg,#10172a,#1b2546);border:1px solid var(--stroke);display:inline-block}
    .crit{font-size:12px;color:var(--muted);display:block;margin-top:6px}
    .small{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <div class="head">
      <div class="logo" aria-label="Logo">
        <span class="dot"></span>
        <div>
          <h1>IELTS Speaking ‚Äî Pro Test</h1>
          <div class="sub">Avto-baholash: Fluency / Lexical / Grammar / Pronunciation + PNG eksport</div>
        </div>
      </div>
      <div class="spacer"></div>
      <button id="btnTheme" class="btn ghost" title="Light/Dark">üåì Tema</button>
      <button id="btnPrint" class="btn ghost">üñ®Ô∏è Chop etish</button>
    </div>
  </header>

  <main class="wrap">
    <div class="grid">
      <section class="card" id="test">
        <h2>Test paneli</h2>
        <p class="muted">Mikrofonga ruxsat bering, keyin <b>Start</b> yoki har bir part uchun ‚è∫Ô∏è tugmasini bosing. Hotkeys: Space ‚Äî toggle record.</p>

        <div class="section">
          <div class="head row">
            <div class="timer" id="globalTimer">00:00</div>
            <span class="pill" id="phasePill">Standby</span>
            <div class="spacer"></div>
            <button id="btnSetup" class="btn">üéôÔ∏è Mic test</button>
            <button id="btnStart" class="btn ok">‚ñ∂Ô∏è Start</button>
            <button id="btnStop" class="btn danger" disabled>‚èπÔ∏è Stop</button>
            <button id="btnReset" class="btn ghost">‚Ü∫ Reset</button>
          </div>
          <div class="body">
            <div class="row" style="align-items:flex-start">
              <div style="flex:1;min-width:260px">
                <div class="label">Ovoz darajasi</div>
                <div class="meter"><div class="bar" id="levelBar"></div></div>
                <canvas id="liveWave" height="46"></canvas>
              </div>
              <div style="min-width:260px">
                <div class="label">Rejim</div>
                <div class="list">
                  <span class="pill" id="micStatus">Mic: unknown</span>
                  <span class="pill" id="recStatus">Rec: idle</span>
                </div>
                <div class="small" style="margin-top:8px">SpeechRecognition: <span id="srStatus">unsupported</span></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Part 1 -->
        <div class="section" id="p1">
          <div class="head row">
            <strong>Part 1 ‚Äî Introduction</strong>
            <span class="pill" id="p1Score">‚Äî</span>
            <div class="spacer"></div>
            <button class="btn" data-rec="p1">‚è∫Ô∏è P1 Start/Stop</button>
          </div>
          <div class="body">
            <div class="qa" id="p1Qs">Savollar...</div>
            <div class="audio-row">
              <audio id="p1Audio" controls></audio>
              <a id="p1Dl" class="btn ghost" download>‚¨áÔ∏è Yuklab olish</a>
              <canvas id="p1Wave" height="46"></canvas>
            </div>
            <div class="crit" id="p1Crit"></div>
          </div>
        </div>

        <!-- Part 2 -->
        <div class="section" id="p2">
          <div class="head row">
            <strong>Part 2 ‚Äî Long Turn</strong>
            <span class="pill" id="p2Score">‚Äî</span>
            <div class="spacer"></div>
            <button class="btn" data-rec="p2">‚è∫Ô∏è P2 Start/Stop</button>
          </div>
          <div class="body">
            <div class="question big prep" id="p2Card">Cue Card‚Ä¶</div>
            <textarea id="p2Notes" placeholder="Eslatmalar"></textarea>
            <div class="audio-row"><audio id="p2Audio" controls></audio><a id="p2Dl" class="btn ghost" download>‚¨áÔ∏è Yuklab olish</a><canvas id="p2Wave" height="46"></canvas></div>
            <div class="crit" id="p2Crit"></div>
          </div>
        </div>

        <!-- Part 3 -->
        <div class="section" id="p3">
          <div class="head row">
            <strong>Part 3 ‚Äî Discussion</strong>
            <span class="pill" id="p3Score">‚Äî</span>
            <div class="spacer"></div>
            <button class="btn" data-rec="p3">‚è∫Ô∏è P3 Start/Stop</button>
          </div>
          <div class="body">
            <div class="qa" id="p3Qs">Savollar...</div>
            <div class="audio-row"><audio id="p3Audio" controls></audio><a id="p3Dl" class="btn ghost" download>‚¨áÔ∏è Yuklab olish</a><canvas id="p3Wave" height="46"></canvas></div>
            <div class="crit" id="p3Crit"></div>
          </div>
        </div>
      </section>

      <aside class="card" id="resultsPanel">
        <h2>Natijalar & Eksport</h2>
        <p class="muted">Avtomatik baholash ‚Äî faqat amaliy qo‚Äòllanma sifatida qarang.</p>

        <div class="section">
          <div class="head"><strong>Baholar</strong></div>
          <div class="body">
            <div class="row"><div>Part 1:</div><div class="pill" id="r_p1">‚Äî</div></div>
            <div class="row"><div>Part 2:</div><div class="pill" id="r_p2">‚Äî</div></div>
            <div class="row"><div>Part 3:</div><div class="pill" id="r_p3">‚Äî</div></div>
            <div style="margin-top:10px" class="row"><div>Overall Speaking Avg:</div><div class="score-pill" id="avgOverall">‚Äî</div></div>
            <div class="small" style="margin-top:8px">Mezonlar: Fluency / Lexical / Grammar / Pronunciation</div>

            <div style="margin-top:12px" class="row">
              <button id="btnExportSession" class="btn">üßæ Seans JSON</button>
              <button id="btnExportAll" class="btn">üì¶ Hammasini ZIP</button>
              <button id="btnExportPNG" class="btn ghost">üñºÔ∏è Export Result PNG</button>
            </div>
          </div>
        </div>
      </aside>
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <script>
    // ----------------- Utilities & State -----------------
    const el = id => document.getElementById(id);
    const parts = ['p1','p2','p3'];
    const state = {
      stream: null,
      recorder: null,
      chunks: [],
      files: {p1:null,p2:null,p3:null},
      currentPart: 'p1',
      audioCtx: null,
      analyser: null,
      dataArray: null,
      recognition: null,
      transcripts: {p1:'', p2:'', p3:''},
      scores: {p1:null,p2:null,p3:null},
      session: {}
    };

    const pad = n => String(n).padStart(2,'0');
    const fmt = s => `${pad(Math.floor(s/60))}:${pad(Math.floor(s%60))}`;

    // ----------------- Mic & Visualiser -----------------
    async function setupMic(){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({audio:true});
        state.stream = stream;
        el('micStatus').textContent = 'Mic: OK';
        state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const src = state.audioCtx.createMediaStreamSource(stream);
        state.analyser = state.audioCtx.createAnalyser();
        state.analyser.fftSize = 512;
        src.connect(state.analyser);
        state.dataArray = new Uint8Array(state.analyser.frequencyBinCount);
        drawLive();
        initSpeechRecognition(); // try to init SpeechRecognition
      }catch(e){
        console.error(e);
        alert('Mikrofon ruxsat etilmadi. Brauzer sozlamalarini tekshiring.');
        el('micStatus').textContent = 'Mic: blocked';
      }
    }

    let liveAnim = null;
    function drawLive(){
      const c = el('liveWave');
      const ctx = c.getContext('2d');
      const w = c.width = c.clientWidth;
      const h = c.height = c.clientHeight;
      if(!state.analyser){ ctx.clearRect(0,0,w,h); return; }
      state.analyser.getByteTimeDomainData(state.dataArray);
      ctx.clearRect(0,0,w,h);
      ctx.lineWidth = 2;
      ctx.strokeStyle = getComputedStyle(document.body).color;
      ctx.beginPath();
      const slice = w / state.dataArray.length;
      for(let i=0;i<state.dataArray.length;i++){
        const x = i*slice;
        const v = (state.dataArray[i]-128)/128;
        const y = h/2 + v*(h/2.2);
        i===0? ctx.moveTo(x,y): ctx.lineTo(x,y);
      }
      ctx.stroke();
      liveAnim = requestAnimationFrame(drawLive);
    }

    // ----------------- Recorder & SpeechRecognition -----------------
    function createRecorder(){
      if(!state.stream) throw new Error('No stream');
      const opts = { mimeType: 'audio/webm' };
      const rec = new MediaRecorder(state.stream, MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? {mimeType:'audio/webm;codecs=opus'} : opts);
      rec.ondataavailable = e => { if(e.data && e.data.size>0) state.chunks.push(e.data); };
      return rec;
    }

    function startRecording(part){
      if(!state.stream){ alert('Avval Mic test bosing'); return false; }
      if(state.recorder && state.recorder.state === 'recording'){ console.warn('Already recording'); return false; }
      state.chunks = [];
      state.recorder = createRecorder();
      state.recorder.start();
      el('recStatus').textContent = 'Rec: recording';
      el(part + 'Status')?.remove?.(); // ignore if not present
      // start SpeechRecognition if available
      if(state.recognition){ state.recognition.lang = 'en-US'; try{ state.recognition.start(); }catch(e){} }
      return true;
    }

    function stopRecording(part){
      return new Promise(resolve=>{
        if(!state.recorder) return resolve(null);
        const rec = state.recorder;
        if(rec.state !== 'recording') return resolve(null);
        rec.onstop = async () => {
          el('recStatus').textContent = 'Rec: saved';
          const blob = new Blob(state.chunks, { type: 'audio/webm' });
          state.files[part] = blob;
          const url = URL.createObjectURL(blob);
          const audioEl = el(part + 'Audio'); if(audioEl){ audioEl.src = url; audioEl.load(); }
          const dl = el(part + 'Dl'); if(dl){ dl.href = url; dl.download = `${new Date().toISOString().slice(0,19).replace(/[:T]/g,'_')}_${part}.webm`; }
          // stop speech recognition
          if(state.recognition){ try{ state.recognition.stop(); }catch(e){} }
          // analyze audio now
          try{ await analyzeBlobAndScore(blob, part); }catch(e){ console.error('Analyze error', e); }
          state.recorder = null;
          resolve(blob);
        };
        try{ rec.stop(); }catch(e){ console.error(e); resolve(null); }
      });
    }

    // ----------------- SpeechRecognition (optional) -----------------
    function initSpeechRecognition(){
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if(!SpeechRecognition){ el('srStatus').textContent = 'unsupported'; return; }
      el('srStatus').textContent = 'available';
      const recog = new SpeechRecognition();
      recog.interimResults = true;
      recog.continuous = true;
      recog.lang = 'en-US';
      recog.onresult = (ev) => {
        let interim = '';
        let final = '';
        for(let i=0;i<ev.results.length;i++){
          const res = ev.results[i];
          if(res.isFinal) final += res[0].transcript + ' ';
          else interim += res[0].transcript + ' ';
        }
        // put interim in current part transcript (append)
        const p = state.currentPart || 'p1';
        // accumulate only finals to avoid duplication
        if(final.trim()) state.transcripts[p] = (state.transcripts[p] + ' ' + final).trim();
        // we won't store interim persistently
      };
      recog.onerror = (e)=>{ console.warn('SR error', e); };
      state.recognition = recog;
    }

    // ----------------- Audio analysis helpers -----------------
    async function decodeAudio(blob){
      const arrayBuf = await blob.arrayBuffer();
      const aCtx = state.audioCtx || new (window.AudioContext || window.webkitAudioContext)();
      return await aCtx.decodeAudioData(arrayBuf);
    }

    function rms(buf){
      let sum=0; for(let i=0;i<buf.length;i++){ const v=buf[i]; sum += v*v; } return Math.sqrt(sum / buf.length);
    }

    function detectSilences(samples, sr, thresh = 0.02, minSilenceLen = 0.5){
      // returns totalSilenceSec and number of long pauses
      const windowMs = 50;
      const winSize = Math.floor(sr * windowMs/1000);
      let totalSilence = 0;
      let longPauses = 0;
      let curSil = 0;
      for(let i=0;i<samples.length;i+=winSize){
        let max = 0;
        for(let j=i;j<Math.min(i+winSize, samples.length); j++){ max = Math.max(max, Math.abs(samples[j])); }
        if(max < thresh){ curSil += winSize/sr; } else { if(curSil >= minSilenceLen) longPauses++; totalSilence += curSil; curSil = 0; }
      }
      if(curSil > 0){ if(curSil >= minSilenceLen) longPauses++; totalSilence += curSil; }
      return { totalSilence, longPauses };
    }

    // simple voicedness: autocorrelation on frames -> fraction of voiced frames
    function voicednessRatio(samples, sr){
      const frameSize = 2048;
      const hop = 1024;
      let voicedFrames = 0, total = 0;
      for(let i=0;i+frameSize < samples.length;i+=hop){
        total++;
        const frame = samples.subarray(i, i+frameSize);
        // remove DC
        let m=0; for(let k=0;k<frame.length;k++) m+=frame[k]; m/=frame.length;
        for(let k=0;k<frame.length;k++) frame[k]-=m;
        // autocorrelation
        let maxCorr = 0;
        const minF = 60, maxF = 400;
        const minLag = Math.floor(sr / maxF);
        const maxLag = Math.floor(sr / minF);
        let norm = 0;
        for(let lag=minLag; lag<=maxLag; lag++){
          let s=0;
          for(let j=0;j<frame.length-lag;j++) s += frame[j]*frame[j+lag];
          if(s > maxCorr) maxCorr = s;
        }
        // energy
        for(let j=0;j<frame.length;j++) norm += frame[j]*frame[j];
        const ratio = norm > 0 ? maxCorr / norm : 0;
        if(ratio > 0.25) voicedFrames++;
      }
      return total ? (voicedFrames / total) : 0;
    }

    // tokenize transcript
    function tokenize(text){
      if(!text) return [];
      return text.toLowerCase().replace(/[^\w'\s]/g,' ').split(/\s+/).filter(Boolean);
    }

    // compute lexical diversity (TTR)
    function lexicalMetrics(words){
      if(words.length===0) return {TTR:0, vocab:0};
      const set = new Set(words);
      return { TTR: set.size / words.length, vocab: set.size };
    }

    // grammar proxy: count filler words
    const fillerList = ['um','uh','like','you know','i mean','so','actually','basically','right','well'];
    function countFillers(words){
      let cnt=0;
      for(let i=0;i<words.length;i++){
        if(fillerList.includes(words[i])) cnt++;
      }
      return cnt;
    }

    // ----------------- Scoring model -----------------
    // maps 0..1 to 0..9
    const to9 = v => Math.max(0, Math.min(9, +(v*9).toFixed(1)));

    async function analyzeBlobAndScore(blob, part){
      const audioBuf = await decodeAudio(blob);
      const data = audioBuf.getChannelData(0);
      const sr = audioBuf.sampleRate;
      const duration = audioBuf.duration;
      // RMS
      const energy = rms(data);
      // silence metrics
      const sil = detectSilences(data, sr, 0.02, 0.6);
      const silenceRatio = duration > 0 ? sil.totalSilence / duration : 0;
      // voicedness
      let voicedRatio = 0;
      try{ voicedRatio = voicednessRatio(data, sr); }catch(e){ console.warn('voicedness failed', e); }
      // transcript metrics (if available)
      const transcript = (state.transcripts[part] || '').trim();
      const words = tokenize(transcript);
      const wordCount = words.length;
      const speechRate = duration>0 ? (wordCount / duration) : 0; // words/sec
      const lex = lexicalMetrics(words);
      const fillerCount = countFillers(words);
      const sentenceCount = Math.max(1, (transcript.match(/[.!?]/g)||[]).length || 1);
      const avgWordsPerSentence = wordCount / sentenceCount;

      // --- Fluency score (proxy)
      // prefer: low silenceRatio, fewer long pauses, reasonable speechRate (~2.5-4.5 w/s)
      const silenceFactor = Math.max(0, 1 - silenceRatio*1.6); // reduce heavily for silence
      const pausePenalty = Math.max(0, 1 - Math.min(5, sil.longPauses)/5); // more long pauses -> penalty
      // normalize speech rate: ideal 2.5..4.5 => map to 0..1
      const rateNorm = Math.max(0, Math.min(1, (speechRate - 1.5) / 3.0));
      const fluencyScore = to9( (silenceFactor*0.6 + pausePenalty*0.2 + rateNorm*0.2) );

      // --- Lexical score (proxy)
      // TTR and vocab size matter
      const ttr = lex.TTR; // 0..1
      const vocab = lex.vocab;
      const vocabNorm = Math.min(1, Math.log10(Math.max(1,vocab)) / 1.6); // log scale
      const lexicalScore = to9( Math.max(0, Math.min(1, ttr*0.6 + vocabNorm*0.4)) );

      // --- Grammar score (proxy)
      // use average words per sentence (too short sentences -> lower), and filler penalty
      const awps = avgWordsPerSentence; // ideal ~8-18
      const awpsScore = Math.max(0, Math.min(1, (awps/12))); // 12 ideal
      const fillerPenalty = Math.max(0, 1 - Math.min(wordCount, fillerCount) / Math.max(1, wordCount) * 2);
      const grammarScore = to9( Math.max(0, awpsScore*0.8 + fillerPenalty*0.2) );

      // --- Pronunciation score (proxy)
      // voicedRatio and energy stability as proxy
      const energyNorm = Math.min(1, energy / 0.1); // rough
      const pronScore = to9( Math.max(0, voicedRatio*0.7 + energyNorm*0.3) );

      // Combine (equal weighting)
      const final = +(( (fluencyScore + lexicalScore + grammarScore + pronScore) / 4 ).toFixed(1));

      // Save and update UI
      state.scores[part] = {
        fluency: fluencyScore,
        lexical: lexicalScore,
        grammar: grammarScore,
        pronunciation: pronScore,
        final
      };

      // update small crit text
      const critEl = el(part + 'Crit');
      if(critEl){
        critEl.innerHTML = `
          <strong>Transcript:</strong> ${transcript ? ('<em>'+transcript+'</em>') : '<em>(no transcript)</em>'}
          <br>
          <span class="small">dur: ${duration.toFixed(1)}s ¬∑ words: ${wordCount} ¬∑ silence: ${(silenceRatio*100).toFixed(1)}% ¬∑ long pauses: ${sil.longPauses} ¬∑ voiced: ${(voicedRatio*100).toFixed(0)}%</span>
        `;
      }

      // update part score pill and results panel values
      el(part + 'Score').textContent = final.toFixed(1);
      el('r_' + part).textContent = final.toFixed(1);
      computeOverallAndDisplay();
    }

    function computeOverallAndDisplay(){
      const vals = [];
      ['p1','p2','p3'].forEach(p=>{
        const s = state.scores[p];
        if(s && typeof s.final === 'number') vals.push(s.final);
      });
      const overall = vals.length ? (vals.reduce((a,b)=>a+b,0)/vals.length) : null;
      el('avgOverall').textContent = overall ? overall.toFixed(1) : '‚Äî';
      if(overall) state.session.overall = overall;
    }

    // ----------------- Hook buttons & flow -----------------
    document.getElementById('btnSetup').addEventListener('click', setupMic);

    // Start / Stop global: Start begins recording for currentPart and starts session timer
    let globalInterval=null, globalStart=0;
    function startGlobal(){
      globalStart = Date.now();
      state.session.startedAt = new Date().toISOString();
      clearInterval(globalInterval);
      globalInterval = setInterval(()=> {
        const s = Math.floor((Date.now() - globalStart)/1000);
        el('globalTimer').textContent = fmt(s);
      },1000);
    }
    function stopGlobal(){
      clearInterval(globalInterval);
      state.session.finishedAt = new Date().toISOString();
    }

    el('btnStart').addEventListener('click', ()=>{
      if(!state.stream){
        if(!confirm('Mikrofon ruxsatisiz davom etilsinmi? (avval Mic test bosing)')) return;
      }
      // start session timer and start recording for currentPart
      startGlobal();
      el('phasePill').textContent = 'Recording';
      el('btnStart').disabled = true;
      el('btnStop').disabled = false;
      state.currentPart = state.currentPart || 'p1';
      startRecording(state.currentPart);
    });

    el('btnStop').addEventListener('click', async ()=>{
      // stop recording if active
      if(state.recorder && state.recorder.state === 'recording'){
        const part = state.currentPart || 'p1';
        await stopRecording(part);
      }
      stopGlobal();
      el('phasePill').textContent = 'Stopped';
      el('btnStart').disabled = false;
      el('btnStop').disabled = true;
      alert('Yozuv to‚Äòxtatildi va baholash bajarildi (agar audio bo‚Äòlsa).');
    });

    // per-part toggle
    document.querySelectorAll('[data-rec]').forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        const part = btn.getAttribute('data-rec');
        // if recording -> stop and analyze
        if(state.recorder && state.recorder.state === 'recording'){
          if(state.currentPart === part){
            await stopRecording(part);
            return;
          } else {
            // stop previous, then start new
            await stopRecording(state.currentPart);
            state.currentPart = part;
            startRecording(part);
            return;
          }
        } else {
          // not recording -> start for this part
          state.currentPart = part;
          startRecording(part);
          // ensure global timer running if not
          if(!globalInterval){ startGlobal(); el('btnStart').disabled = true; el('btnStop').disabled = false; }
        }
      });
    });

    el('btnReset').addEventListener('click', ()=>{
      if(!confirm('Butun sessiyani reset qilinsinmi?')) return;
      if(state.recorder && state.recorder.state === 'recording'){ try{ state.recorder.stop(); }catch(e){} }
      stopGlobal();
      parts.forEach(p=>{
        state.files[p]=null;
        state.transcripts[p]='';
        state.scores[p]=null;
        const a = el(p+'Audio'); if(a) a.src='';
        el(p+'Score').textContent = '‚Äî';
        el('r_'+p).textContent = '‚Äî';
        const crit = el(p+'Crit'); if(crit) crit.innerHTML='';
        const c = el(p+'Wave'); if(c) c.getContext('2d').clearRect(0,0,c.width,c.height);
      });
      el('globalTimer').textContent = '00:00';
      el('phasePill').textContent = 'Standby';
      el('btnStart').disabled = false;
      el('btnStop').disabled = true;
      el('avgOverall').textContent = '‚Äî';
      state.session = {};
    });

    // ----------------- drawRecordedWave for each part -----------------
    async function drawRecordedWave(blob, part){
      try{
        const ctx = el(part + 'Wave').getContext('2d');
        const arrayBuf = await blob.arrayBuffer();
        const aCtx = state.audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        const audioBuf = await aCtx.decodeAudioData(arrayBuf);
        const data = audioBuf.getChannelData(0);
        const len = 800;
        const step = Math.max(1, Math.floor(data.length / len));
        const w = ctx.canvas.width = ctx.canvas.clientWidth;
        const h = ctx.canvas.height = ctx.canvas.clientHeight;
        const amp = h/2 - 2;
        ctx.clearRect(0,0,w,h);
        ctx.lineWidth = 2;
        ctx.strokeStyle = getComputedStyle(document.body).color;
        ctx.beginPath();
        for(let i=0;i<len;i++){
          let min=1,max=-1;
          for(let j=0;j<step;j++){
            const idx = i*step + j;
            if(idx >= data.length) break;
            const v = data[idx];
            if(v < min) min = v;
            if(v > max) max = v;
          }
          const x = i * (w/len);
          ctx.moveTo(x, (1 + min) * amp);
          ctx.lineTo(x, (1 + max) * amp);
        }
        ctx.stroke();
      }catch(e){ console.warn('drawRecordedWave err', e); }
    }

    // expose draw wave when saved (wrap around analyze)
    async function drawWave(blob, part){
      await drawRecordedWave(blob, part);
    }

    // update analyzeBlobAndScore to call drawWave
    async function analyzeBlobAndScore(blob, part){
      // call earlier analyzer (we already defined but redeclare to ensure drawWave is called)
      // reuse earlier function body by calling it, but ensure drawWave is called
      await (async function inner(blob, part){
        const audioBuf = await decodeAudio(blob);
        const data = audioBuf.getChannelData(0);
        const sr = audioBuf.sampleRate;
        const duration = audioBuf.duration;
        const energy = rms(data);
        const sil = detectSilences(data, sr, 0.02, 0.6);
        const silenceRatio = duration > 0 ? sil.totalSilence / duration : 0;
        let voicedRatio = 0;
        try{ voicedRatio = voicednessRatio(data, sr); }catch(e){ console.warn('voicedness failed', e); }
        const transcript = (state.transcripts[part] || '').trim();
        const words = tokenize(transcript);
        const wordCount = words.length;
        const speechRate = duration>0 ? (wordCount / duration) : 0;
        const lex = lexicalMetrics(words);
        const fillerCount = countFillers(words);
        const sentenceCount = Math.max(1, (transcript.match(/[.!?]/g)||[]).length || 1);
        const avgWordsPerSentence = wordCount / sentenceCount;
        const silenceFactor = Math.max(0, 1 - silenceRatio*1.6);
        const pausePenalty = Math.max(0, 1 - Math.min(5, sil.longPauses)/5);
        const rateNorm = Math.max(0, Math.min(1, (speechRate - 1.5) / 3.0));
        const fluencyScore = to9( (silenceFactor*0.6 + pausePenalty*0.2 + rateNorm*0.2) );
        const ttr = lex.TTR; const vocab = lex.vocab;
        const vocabNorm = Math.min(1, Math.log10(Math.max(1,vocab)) / 1.6);
        const lexicalScore = to9( Math.max(0, Math.min(1, ttr*0.6 + vocabNorm*0.4)) );
        const awps = avgWordsPerSentence; const awpsScore = Math.max(0, Math.min(1, (awps/12)));
        const fillerPenalty = Math.max(0, 1 - Math.min(wordCount, fillerCount) / Math.max(1, wordCount) * 2);
        const grammarScore = to9( Math.max(0, awpsScore*0.8 + fillerPenalty*0.2) );
        const energyNorm = Math.min(1, energy / 0.1);
        const pronScore = to9( Math.max(0, voicedRatio*0.7 + energyNorm*0.3) );
        const final = +(( (fluencyScore + lexicalScore + grammarScore + pronScore) / 4 ).toFixed(1));
        state.scores[part] = { fluency:fluencyScore, lexical:lexicalScore, grammar:grammarScore, pronunciation:pronScore, final };
        // update UI
        el(part + 'Score').textContent = final.toFixed(1);
        el('r_' + part).textContent = final.toFixed(1);
        const critEl = el(part + 'Crit');
        if(critEl){
          critEl.innerHTML = `<strong>Transcript:</strong> ${transcript ? ('<em>'+transcript+'</em>') : '<em>(no transcript)</em>'}
            <br><span class="small">dur: ${duration.toFixed(1)}s ¬∑ words: ${wordCount} ¬∑ silence: ${(silenceRatio*100).toFixed(1)}% ¬∑ long pauses: ${sil.longPauses} ¬∑ voiced: ${(voicedRatio*100).toFixed(0)}%</span>`;
        }
        // draw waveform
        await drawWave(blob, part);
        computeOverallAndDisplay();
      })(blob, part);
    }

    // ----------------- Export handlers -----------------
    el('btnExportSession').addEventListener('click', ()=>{
      state.session.transcripts = state.transcripts; state.session.scores = state.scores;
      const blob = new Blob([JSON.stringify(state.session,null,2)],{type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = `speaking_session_${new Date().toISOString().slice(0,10)}.json`; a.click(); URL.revokeObjectURL(url);
    });

    el('btnExportAll').addEventListener('click', async ()=>{
      const zip = new JSZip();
      zip.file('session.json', JSON.stringify(state.session,null,2));
      for(const p of parts){
        if(state.files[p]) zip.file(`${p}.webm`, state.files[p]);
      }
      const blob = await zip.generateAsync({type:'blob'});
      const url = URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download = `speaking_${new Date().toISOString().slice(0,10)}.zip`; a.click(); URL.revokeObjectURL(url);
    });

    el('btnExportPNG').addEventListener('click', async ()=>{
      try{
        const node = el('resultsPanel');
        el('btnExportPNG').textContent = 'üîÑ Generating...';
        const canvas = await html2canvas(node, {scale:2, useCORS:true, backgroundColor: getComputedStyle(document.body).backgroundColor});
        canvas.toBlob((blob)=>{
          const url = URL.createObjectURL(blob);
          const a=document.createElement('a'); a.href=url; a.download = `speaking_results_${new Date().toISOString().slice(0,10)}.png`; a.click(); URL.revokeObjectURL(url);
          el('btnExportPNG').textContent = 'üñºÔ∏è Export Result PNG';
        }, 'image/png');
      }catch(e){ alert('PNG yaratishda xato: ' + e); el('btnExportPNG').textContent = 'üñºÔ∏è Export Result PNG'; }
    });

    // ----------------- Hotkeys: Space toggles recording for current part -----------------
    window.addEventListener('keydown', async (e)=>{
      if(e.code === 'Space' && (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA')){
        e.preventDefault();
        // toggle
        if(state.recorder && state.recorder.state === 'recording'){
          const part = state.currentPart || 'p1';
          await stopRecording(part);
        } else {
          const part = state.currentPart || 'p1';
          startRecording(part);
          if(!globalInterval) startGlobal();
          el('btnStart').disabled = true; el('btnStop').disabled = false;
        }
      }
    });

    // ----------------- Initialize UI -----------------
    function genQuestions(){
      el('p1Qs').innerHTML = '<div class="question">What do you do in your free time?</div><div class="question">Do you prefer mornings or evenings?</div>';
      el('p2Card').textContent = 'Describe a memorable journey you had. You should say: where you went, how you traveled, and explain why it was memorable.';
      el('p3Qs').innerHTML = '<div class="question">How has technology changed communication?</div><div class="question">What makes a city livable?</div>';
    }
    genQuestions();
    // speech recognition status init
    el('srStatus').textContent = (window.SpeechRecognition || window.webkitSpeechRecognition) ? 'available' : 'unsupported';
  </script>
</body>
</html>
